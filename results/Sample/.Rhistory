rcFSMat <- matrix(fSub,ncol=3,byrow=TRUE)
fakeSub <- reclassify(fakeSub,rcFSMat)
# Sets cells with unacceptable substrate types to NA and acceptable types to 1
fakeSub[fakeSub != subTab] <- NA
fakeSub[fakeSub == subTab] <- 1
spplot(fakeSub)
head(fakeSub)
fakeSub
if(CheckSub == "1"){
subTab <- sub_allages[,b] # creates table of substrate for current lifestage
hhList <- goodHabList[[b]] # holds rasters of area for current lifestage
goodHabList[[b]] <- by.substrate(hhList,subTab)
} # end of if statement
if(CheckSub == "1"){
subTab <- sub_allages[,b] # creates table of substrate for current lifestage
hhList <- goodHabList[[b]] # holds rasters of area for current lifestage
goodHabList[[b]] <- by.substrate(hhList,subTab)
} # end of if statement
## Reclassify Bricks with hydraulic and substrate HSC by lifestage
hsc_allages<-fread(paste(wd,species,"_hsc",".csv",sep = ""), header=TRUE, sep=",")
if(CheckSub == "1"){sub_allages<-fread(paste(wd,species,"_substrate",".csv",sep=""),header=TRUE, sep = ",",data.table = FALSE)} # load substrate requirements
goodHabList <- list() # list that will hold suitable hydraulic habitat by lifestage
for(b in 1:length(lifestages)){
hsc <- hsc_allages[b] # creates HSC table for current lifestage
goodHabList[[b]] <- stacks.rc(iricValRast,hsc,habMets)
if(CheckSub == "1"){
subTab <- sub_allages[,b] # creates table of substrate for current lifestage
hhList <- goodHabList[[b]] # holds rasters of area for current lifestage
goodHabList[[b]] <- by.substrate(hhList,subTab)
} # end of if statement
} # end of for loop
names(goodHabList) <- lifestages # list of Bricks by lifestage
source(paste(wd,"by.substrate.R",sep="\\"))
View(sub_allages)
subTab <- sub_allages[,1]
# Sets cells with unacceptable substrate types to NA and acceptable types to 1
fakeSub[fakeSub != subTab] <- NA
fakeSub[fakeSub == subTab] <- 1
plot(fakeSub)
subTab <- sub_allages[,2]
subVec <- as.vector(subTab)
subVec <- as.numeric(subTab)
subVec <- subTab[!is.na(subTab)]
# Sets cells with unacceptable substrate types to NA and acceptable types to 1
fakeSub[fakeSub != subVec] <- NA
fakeSub[fakeSub == subVec] <- 1
plot(fakeSub)
class(subVec)
subTab <- sub_allages[,1]
subInt <- subTab[!is.na(subTab)]
subTab <- sub_allages[,2]
subInt <- subTab[!is.na(subTab)]
# Function: This script serves as the master script that controls which functions are run and what inputs are used for finding suitable fish habitat
#         It will later be converted to the script that controls the Shiny App.
# Last edited by Elaina Passero on 02/29/19
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis","ggplot2","data.table","dpylr")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
# load the installed libraries in the packages list
lapply(packages,library,character.only=TRUE)
# Set Inputs
wd <- "C:\\Users\\epassero\\Desktop\\VRDSS\\verde-refdss\\" # Set path to local repository
habMets <- list("Depth","Velocity..magnitude.") #Variables from iRIC calculation result used for habitat analysis
species <- "fakefish"
lifestages <- list("adult","juvenile") #lifestages from oldest to youngest; must match order in HSC table
reachName <- "Sample" # 1Beasley or Sample
DEM <- "smrf_DEM_v241.tif" # Name of DEM used in iRIC: VerdeBeasley1Elev.tif or smrf_DEM_v241.tif
disunit <- "cms" #units of discharge
# Options: Currently this is only set up to run with the Sample reach
CheckSub <- 1 # 1 (Yes) or 0 (No). Choose whether or not to check substrate conditions as part of suitable habitat
CalcEffArea <- 1 # 1 (Yes) or 0 (No). Choose whether or not to calculate effective habitat area
# Load functions
source(paste(wd,"get.results.R",sep="\\"))
source(paste(wd,"iric.process.smr.R",sep="\\"))
source(paste(wd,"stacks.rc.R",sep="\\"))
source(paste(wd,"by.substrate.R",sep="\\"))
source(paste(wd,"brick.2.spdf.R",sep="\\"))
source(paste(wd,"effective.area.R",sep="\\"))
# Run functions
## Format result CSVs and get list of discharges
holdList <- get.results(wd,reachName,disunit)
csvList <- holdList$csvList
modeled_q <- holdList$modeled_q
rm(holdList)
## Convert iRIC outputs to rasterBricks by variable
iricValRast <- list()
iricValRast <- lapply(habMets, function(a) iric.process.smr(a,csvList,wd,DEM,reachName))
names(iricValRast) <-habMets
rm(csvList)
## Reclassify Bricks with hydraulic and substrate HSC by lifestage
hsc_allages<-fread(paste(wd,species,"_hsc",".csv",sep = ""), header=TRUE, sep=",")
if(CheckSub == "1"){sub_allages<-fread(paste(wd,species,"_substrate",".csv",sep=""),header=TRUE, sep = ",",data.table = FALSE)} # load substrate requirements
goodHabList <- list() # list that will hold suitable hydraulic habitat by lifestage
for(b in 1:length(lifestages)){
hsc <- hsc_allages[b] # creates HSC table for current lifestage
goodHabList[[b]] <- stacks.rc(iricValRast,hsc,habMets)
if(CheckSub == "1"){
subTab <- sub_allages[,b] # creates table of substrate for current lifestage
hhList <- goodHabList[[b]] # holds rasters of area for current lifestage
goodHabList[[b]] <- by.substrate(hhList,subTab)
} # end of if statement
} # end of for loop
names(goodHabList) <- lifestages # list of Bricks by lifestage
## Total available habitat area by lifestage
goodPolyList <- lapply(goodHabList, function(c) brick.2.spdf(c))
## Effective habitat area
if (CalcEffArea == 1){
whatever <- lapply(lifestages,function(e) effective.area(e,goodPolyList))
}
subInt <- subTab[!is.na(subTab)]
fakeSub[fakeSub != subInt] <- NA
fakeSub[fakeSub == subInt] <- 1
plot(fakeSub)
subTab <- sub_allages[,1]
subInt <- subTab[!is.na(subTab)]
fakeSub[fakeSub != subInt] <- NA
fakeSub[fakeSub == subInt] <- 1
plot(fakeSub)
goodPolyList[,1]
goodPolyList[[1]]
goodPolyList[[2]]
# Function: This script serves as the master script that controls which functions are run and what inputs are used for finding suitable fish habitat
#         It will later be converted to the script that controls the Shiny App.
# Last edited by Elaina Passero on 02/29/19
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis","ggplot2","data.table","dpylr")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
# load the installed libraries in the packages list
lapply(packages,library,character.only=TRUE)
# Set Inputs
wd <- "C:\\Users\\epassero\\Desktop\\VRDSS\\verde-refdss\\" # Set path to local repository
habMets <- list("Depth","Velocity..magnitude.") #Variables from iRIC calculation result used for habitat analysis
species <- "fakefish"
lifestages <- list("adult","juvenile") #lifestages from oldest to youngest; must match order in HSC table
reachName <- "Sample" # 1Beasley or Sample
DEM <- "smrf_DEM_v241.tif" # Name of DEM used in iRIC: VerdeBeasley1Elev.tif or smrf_DEM_v241.tif
disunit <- "cms" #units of discharge
# Options: Currently this is only set up to run with the Sample reach
CheckSub <- 1 # 1 (Yes) or 0 (No). Choose whether or not to check substrate conditions as part of suitable habitat
CalcEffArea <- 0 # 1 (Yes) or 0 (No). Choose whether or not to calculate effective habitat area
# Load functions
source(paste(wd,"get.results.R",sep="\\"))
source(paste(wd,"iric.process.smr.R",sep="\\"))
source(paste(wd,"bricks.rc.R",sep="\\"))
source(paste(wd,"by.substrate.R",sep="\\"))
source(paste(wd,"brick.2.spdf.R",sep="\\"))
source(paste(wd,"effective.area.R",sep="\\"))
# Run functions
## Format result CSVs and get list of discharges
holdList <- get.results(wd,reachName,disunit)
csvList <- holdList$csvList
modeled_q <- holdList$modeled_q
rm(holdList)
## Convert iRIC outputs to rasterBricks by variable
iricValRast <- list()
iricValRast <- lapply(habMets, function(a) iric.process.smr(a,csvList,wd,DEM,reachName))
names(iricValRast) <-habMets
rm(csvList)
## Reclassify Bricks with hydraulic and substrate HSC by lifestage
hsc_allages<-fread(paste(wd,species,"_hsc",".csv",sep = ""), header=TRUE, sep=",")
if(CheckSub == "1"){sub_allages<-fread(paste(wd,species,"_substrate",".csv",sep=""),header=TRUE, sep = ",",data.table = FALSE)} # load substrate requirements
goodHabList <- list() # list that will hold suitable hydraulic habitat by lifestage
for(b in 1:length(lifestages)){
hsc <- hsc_allages[b] # creates HSC table for current lifestage
goodHabList[[b]] <- bricks.rc(iricValRast,hsc,habMets)
if(CheckSub == "1"){
subTab <- sub_allages[,b] # creates table of substrate for current lifestage
hhList <- goodHabList[[b]] # holds rasters of area for current lifestage
goodHabList[[b]] <- by.substrate(hhList,subTab)
} # end of if statement
} # end of for loop
names(goodHabList) <- lifestages # list of Bricks by lifestage
## Total available habitat area by lifestage
goodPolyList <- lapply(goodHabList, function(c) brick.2.spdf(c))
## Effective habitat area
### Not functional yet
if (CalcEffArea == 1){
EffTab <- lapply(lifestages,function(e) effective.area(e,goodPolyList))
}
plot(goodPolyList[[1]])
spplot(goodPolyList[[1]])
spplot(goodPolyList$adult)
spplot(goodPolyList[[1]]@polygons)
goodPolyList[[1]]
goodPolyList$adult[[1]]
plot(goodPolyList$adult[[1]])
spplot(goodPolyList$adult)
lapply(spplot,goodPolyList)
lapply(goodPolyList,spplot)
lapply(goodPolyList$adult,spplot)
View(hsc)
View(hsc_allages)
# Function: This script serves as the master script that controls which functions are run and what inputs are used for finding suitable fish habitat
#         It will later be converted to the script that controls the Shiny App.
# Last edited by Elaina Passero on 02/29/19
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis","ggplot2","data.table","dpylr")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
# load the installed libraries in the packages list
lapply(packages,library,character.only=TRUE)
# Set Inputs
wd <- "C:\\Users\\epassero\\Desktop\\VRDSS\\verde-refdss\\" # Set path to local repository
habMets <- list("Depth","Velocity..magnitude.") #Variables from iRIC calculation result used for habitat analysis
species <- "fakefish"
lifestages <- list("adult","juvenile") #lifestages from oldest to youngest; must match order in HSC table
reachName <- "Sample" # 1Beasley or Sample
DEM <- "smrf_DEM_v241.tif" # Name of DEM used in iRIC: VerdeBeasley1Elev.tif or smrf_DEM_v241.tif
disunit <- "cms" #units of discharge
# Options: Currently this is only set up to run with the Sample reach
CheckSub <- 1 # 1 (Yes) or 0 (No). Choose whether or not to check substrate conditions as part of suitable habitat
CalcEffArea <- 0 # 1 (Yes) or 0 (No). Choose whether or not to calculate effective habitat area
# Load functions
source(paste(wd,"get.results.R",sep="\\"))
source(paste(wd,"iric.process.smr.R",sep="\\"))
source(paste(wd,"bricks.rc.R",sep="\\"))
source(paste(wd,"by.substrate.R",sep="\\"))
source(paste(wd,"brick.2.spdf.R",sep="\\"))
source(paste(wd,"effective.area.R",sep="\\"))
# Run functions
## Format result CSVs and get list of discharges
holdList <- get.results(wd,reachName,disunit)
csvList <- holdList$csvList
modeled_q <- holdList$modeled_q
rm(holdList)
## Convert iRIC outputs to rasterBricks by variable
iricValRast <- list()
iricValRast <- lapply(habMets, function(a) iric.process.smr(a,csvList,wd,DEM,reachName))
names(iricValRast) <-habMets
rm(csvList)
## Reclassify Bricks with hydraulic and substrate HSC by lifestage
hsc_allages<-fread(paste(wd,species,"_hsc",".csv",sep = ""), header=TRUE, sep=",")
if(CheckSub == "1"){sub_allages<-fread(paste(wd,species,"_substrate",".csv",sep=""),header=TRUE, sep = ",",data.table = FALSE)} # load substrate requirements
goodHabList <- list() # list that will hold suitable hydraulic habitat by lifestage
for(b in 1:length(lifestages)){
hsc <- hsc_allages[b] # creates HSC table for current lifestage
goodHabList[[b]] <- bricks.rc(iricValRast,hsc,habMets)
if(CheckSub == "1"){
subTab <- sub_allages[,b] # creates table of substrate for current lifestage
hhList <- goodHabList[[b]] # holds rasters of area for current lifestage
goodHabList[[b]] <- by.substrate(hhList,subTab)
} # end of if statement
} # end of for loop
names(goodHabList) <- lifestages # list of Bricks by lifestage
goodHabList
## Total available habitat area by lifestage
goodPolyList <- lapply(goodHabList, function(c) brick.2.spdf(c))
is.null(goodHabList$adult)
is.na(goodHabList$adult)
goodHabList$adult
is.NA(goodHabList$adult)
is.na(goodHabList$adult)
length(goodHabList$adult)
max(goodHabList$adult)
fg<-max(goodHabList$adult)
rm(fg)
anyNA(goodHabList$adult)
sum(goodHabList$adult)
maxValue(goodHabList$adult)
max(maxValue(goodHabList$adult))
!is.na(maxValue(goodHabList$adult))
check <- goodHabList$adult
check <- goodPolyList$adult
check[,1]
check[1,]
check@data
check[1]
check[[1]][,1]
rastList <- unstack(goodHabList$adult)
spdfList <- lapply(rastList,function(d) {
if(is.na(maxValue(d))==FALSE){
disSPDF <- rasterToPolygons(d,dissolve = TRUE)
disSPDF <- sp::disaggregate(disSPDF) # each sub-poly becomes its own polygon
disSPDF$area <- gArea(disSPDF,byid=TRUE) # calculate the area for each polygon as a new variable
disSPDF <- disSPDF[disSPDF$area > 0.25,] # remove polygons that were only one raster cell
} else {
spdfList[[d]][,1] <- 0 # at this specific discharge, the value slot changed to 0
spdfList[[d]]$area <- 0 # set area = 0
}
}) # end of lapply expression
return(spdfList)
spdfList <- list()
rastList <- unstack(goodHabList$adult)
spdfList <- list()
spdfList <- lapply(rastList,function(d) {
if(is.na(maxValue(d))==FALSE){
disSPDF <- rasterToPolygons(d,dissolve = TRUE)
disSPDF <- sp::disaggregate(disSPDF) # each sub-poly becomes its own polygon
disSPDF$area <- gArea(disSPDF,byid=TRUE) # calculate the area for each polygon as a new variable
disSPDF <- disSPDF[disSPDF$area > 0.25,] # remove polygons that were only one raster cell
} else {
spdfList[[d]][,1] <- 0 # at this specific discharge, the value slot changed to 0
spdfList[[d]]$area <- 0 # set area = 0
}
}) # end of lapply expression
spdfList <- lapply(rastList,function(d) {
if(is.na(maxValue(d))==FALSE){
disSPDF <- rasterToPolygons(d,dissolve = TRUE)
disSPDF <- sp::disaggregate(disSPDF) # each sub-poly becomes its own polygon
disSPDF$area <- gArea(disSPDF,byid=TRUE) # calculate the area for each polygon as a new variable
disSPDF <- disSPDF[disSPDF$area > 0.25,] # remove polygons that were only one raster cell
} else {
spdfList[[d]][,1] <- 0 # at this specific discharge, the value slot changed to 0
spdfList[[d]]$area <- 0 # set area = 0
}
})
rastList <- unstack(goodHabList$adult)
spdfList <- list()
spdfList <- lapply(rastList,function(d) {
if(is.na(maxValue(d))==FALSE){
disSPDF <- rasterToPolygons(d,dissolve = TRUE)
disSPDF <- sp::disaggregate(disSPDF) # each sub-poly becomes its own polygon
disSPDF$area <- gArea(disSPDF,byid=TRUE) # calculate the area for each polygon as a new variable
disSPDF <- disSPDF[disSPDF$area > 0.25,] # remove polygons that were only one raster cell
} else {
notPoly[,1] <- 0 # at this specific discharge, the value slot changed to 0
notPoly$area <- 0 # set area = 0
}
}) # end of lapply expression
notPoly[1,1]<-2
## Total available habitat area by lifestage
goodPolyList <- lapply(goodHabList, function(c) brick.2.spdf(c))
spdfList <- lapply(rastList,function(d) {
if(is.na(maxValue(d))==FALSE){
disSPDF <- rasterToPolygons(d,dissolve = TRUE)
disSPDF <- sp::disaggregate(disSPDF) # each sub-poly becomes its own polygon
disSPDF$area <- gArea(disSPDF,byid=TRUE) # calculate the area for each polygon as a new variable
disSPDF <- disSPDF[disSPDF$area > 0.25,] # remove polygons that were only one raster cell
} # end of if statement
source(paste(wd,"brick.2.spdf.R",sep="\\"))
## Total available habitat area by lifestage
goodPolyList <- lapply(goodHabList, function(c) brick.2.spdf(c))
# Function: This script serves as the master script that controls which functions are run and what inputs are used for finding suitable fish habitat
#         It will later be converted to the script that controls the Shiny App.
# Last edited by Elaina Passero on 02/29/19
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis","ggplot2","data.table","dpylr")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
# load the installed libraries in the packages list
lapply(packages,library,character.only=TRUE)
# Set Inputs
wd <- "C:\\Users\\epassero\\Desktop\\VRDSS\\verde-refdss\\" # Set path to local repository
habMets <- list("Depth","Velocity..magnitude.") #Variables from iRIC calculation result used for habitat analysis
species <- "fakefish"
lifestages <- list("adult","juvenile") #lifestages from oldest to youngest; must match order in HSC table
reachName <- "Sample" # 1Beasley or Sample
DEM <- "smrf_DEM_v241.tif" # Name of DEM used in iRIC: VerdeBeasley1Elev.tif or smrf_DEM_v241.tif
disunit <- "cms" #units of discharge
# Options: Currently this is only set up to run with the Sample reach
CheckSub <- 1 # 1 (Yes) or 0 (No). Choose whether or not to check substrate conditions as part of suitable habitat
CalcEffArea <- 0 # 1 (Yes) or 0 (No). Choose whether or not to calculate effective habitat area
# Load functions
source(paste(wd,"get.results.R",sep="\\"))
source(paste(wd,"iric.process.smr.R",sep="\\"))
source(paste(wd,"bricks.rc.R",sep="\\"))
source(paste(wd,"by.substrate.R",sep="\\"))
source(paste(wd,"brick.2.spdf.R",sep="\\"))
source(paste(wd,"effective.area.R",sep="\\"))
# Run functions
## Format result CSVs and get list of discharges
holdList <- get.results(wd,reachName,disunit)
csvList <- holdList$csvList
modeled_q <- holdList$modeled_q
rm(holdList)
## Convert iRIC outputs to rasterBricks by variable
iricValRast <- list()
iricValRast <- lapply(habMets, function(a) iric.process.smr(a,csvList,wd,DEM,reachName))
names(iricValRast) <-habMets
rm(csvList)
## Reclassify Bricks with hydraulic and substrate HSC by lifestage
hsc_allages<-fread(paste(wd,species,"_hsc",".csv",sep = ""), header=TRUE, sep=",")
if(CheckSub == "1"){sub_allages<-fread(paste(wd,species,"_substrate",".csv",sep=""),header=TRUE, sep = ",",data.table = FALSE)} # load substrate requirements
goodHabList <- list() # list that will hold suitable hydraulic habitat by lifestage
for(b in 1:length(lifestages)){
hsc <- hsc_allages[b] # creates HSC table for current lifestage
goodHabList[[b]] <- bricks.rc(iricValRast,hsc,habMets)
if(CheckSub == "1"){
subTab <- sub_allages[,b] # creates table of substrate for current lifestage
hhList <- goodHabList[[b]] # holds rasters of area for current lifestage
goodHabList[[b]] <- by.substrate(hhList,subTab)
} # end of if statement
} # end of for loop
names(goodHabList) <- lifestages # list of Bricks by lifestage
## Total available habitat area by lifestage
goodPolyList <- lapply(goodHabList, function(c) brick.2.spdf(c))
## Effective habitat area
### Not functional yet
if (CalcEffArea == 1){
EffTab <- lapply(lifestages,function(e) effective.area(e,goodPolyList))
}
# Function: This script serves as the master script that controls which functions are run and what inputs are used for finding suitable fish habitat
#         It will later be converted to the script that controls the Shiny App.
# Last edited by Elaina Passero on 02/29/19
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis","ggplot2","data.table","dpylr")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
# load the installed libraries in the packages list
lapply(packages,library,character.only=TRUE)
# Set Inputs
wd <- "C:\\Users\\epassero\\Desktop\\VRDSS\\verde-refdss\\" # Set path to local repository
habMets <- list("Depth","Velocity..magnitude.") #Variables from iRIC calculation result used for habitat analysis
species <- "fakefish"
lifestages <- list("adult","juvenile") #lifestages from oldest to youngest; must match order in HSC table
reachName <- "Sample" # 1Beasley or Sample
DEM <- "smrf_DEM_v241.tif" # Name of DEM used in iRIC: VerdeBeasley1Elev.tif or smrf_DEM_v241.tif
disunit <- "cms" #units of discharge
# Options: Currently this is only set up to run with the Sample reach
CheckSub <- 1 # 1 (Yes) or 0 (No). Choose whether or not to check substrate conditions as part of suitable habitat
CalcEffArea <- 0 # 1 (Yes) or 0 (No). Choose whether or not to calculate effective habitat area
# Load functions
source(paste(wd,"get.results.R",sep="\\"))
source(paste(wd,"iric.process.smr.R",sep="\\"))
source(paste(wd,"bricks.rc.R",sep="\\"))
source(paste(wd,"by.substrate.R",sep="\\"))
source(paste(wd,"brick.2.spdf.R",sep="\\"))
source(paste(wd,"effective.area.R",sep="\\"))
# Run functions
## Format result CSVs and get list of discharges
holdList <- get.results(wd,reachName,disunit)
csvList <- holdList$csvList
modeled_q <- holdList$modeled_q
rm(holdList)
## Convert iRIC outputs to rasterBricks by variable
iricValRast <- list()
iricValRast <- lapply(habMets, function(a) iric.process.smr(a,csvList,wd,DEM,reachName))
names(iricValRast) <-habMets
rm(csvList)
## Reclassify Bricks with hydraulic and substrate HSC by lifestage
hsc_allages<-fread(paste(wd,species,"_hsc",".csv",sep = ""), header=TRUE, sep=",")
if(CheckSub == "1"){sub_allages<-fread(paste(wd,species,"_substrate",".csv",sep=""),header=TRUE, sep = ",",data.table = FALSE)} # load substrate requirements
goodHabList <- list() # list that will hold suitable hydraulic habitat by lifestage
for(b in 1:length(lifestages)){
hsc <- hsc_allages[b] # creates HSC table for current lifestage
goodHabList[[b]] <- bricks.rc(iricValRast,hsc,habMets)
if(CheckSub == "1"){
subTab <- sub_allages[,b] # creates table of substrate for current lifestage
hhList <- goodHabList[[b]] # holds rasters of area for current lifestage
goodHabList[[b]] <- by.substrate(hhList,subTab)
} # end of if statement
} # end of for loop
names(goodHabList) <- lifestages # list of Bricks by lifestage
## Total available habitat area by lifestage
goodPolyList <- lapply(goodHabList, function(c) brick.2.spdf(c))
## Effective habitat area
### Not functional yet
if (CalcEffArea == 1){
EffTab <- lapply(lifestages,function(e) effective.area(e,goodPolyList))
}
# Set Inputs
wd <- "C:\\Users\\epassero\\Desktop\\VRDSS\\verde-refdss\\" # Set path to local repository
habMets <- list("Depth","Velocity..magnitude.") #Variables from iRIC calculation result used for habitat analysis
species <- "fakefish"
lifestages <- list("adult","juvenile") #lifestages from oldest to youngest; must match order in HSC table
reachName <- "Sample" # 1Beasley or Sample
DEM <- "smrf_DEM_v241.tif" # Name of DEM used in iRIC: VerdeBeasley1Elev.tif or smrf_DEM_v241.tif
disunit <- "cms" #units of discharge
# Options: Currently this is only set up to run with the Sample reach
CheckSub <- 1 # 1 (Yes) or 0 (No). Choose whether or not to check substrate conditions as part of suitable habitat
CalcEffArea <- 0 # 1 (Yes) or 0 (No). Choose whether or not to calculate effective habitat area
# Load functions
source(paste(wd,"get.results.R",sep="\\"))
source(paste(wd,"iric.process.smr.R",sep="\\"))
source(paste(wd,"bricks.rc.R",sep="\\"))
source(paste(wd,"by.substrate.R",sep="\\"))
source(paste(wd,"brick.2.spdf.R",sep="\\"))
source(paste(wd,"effective.area.R",sep="\\"))
# Run functions
## Format result CSVs and get list of discharges
holdList <- get.results(wd,reachName,disunit)
csvList <- holdList$csvList
modeled_q <- holdList$modeled_q
rm(holdList)
## Convert iRIC outputs to rasterBricks by variable
iricValRast <- list()
iricValRast <- lapply(habMets, function(a) iric.process.smr(a,csvList,wd,DEM,reachName))
names(iricValRast) <-habMets
rm(csvList)
## Reclassify Bricks with hydraulic and substrate HSC by lifestage
hsc_allages<-fread(paste(wd,species,"_hsc",".csv",sep = ""), header=TRUE, sep=",")
if(CheckSub == "1"){sub_allages<-fread(paste(wd,species,"_substrate",".csv",sep=""),header=TRUE, sep = ",",data.table = FALSE)} # load substrate requirements
goodHabList <- list() # list that will hold suitable hydraulic habitat by lifestage
for(b in 1:length(lifestages)){
hsc <- hsc_allages[b] # creates HSC table for current lifestage
goodHabList[[b]] <- bricks.rc(iricValRast,hsc,habMets)
if(CheckSub == "1"){
subTab <- sub_allages[,b] # creates table of substrate for current lifestage
hhList <- goodHabList[[b]] # holds rasters of area for current lifestage
goodHabList[[b]] <- by.substrate(hhList,subTab)
} # end of if statement
} # end of for loop
names(goodHabList) <- lifestages # list of Bricks by lifestage
## Total available habitat area by lifestage
goodPolyList <- lapply(goodHabList, function(c) brick.2.spdf(c))
## Effective habitat area
### Not functional yet
if (CalcEffArea == 1){
EffTab <- lapply(lifestages,function(e) effective.area(e,goodPolyList))
}
