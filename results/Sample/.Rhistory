#e2Line<-Line(edge2[,3:4])
#e3Line<-Line(edge3[,3:4])
#e4Line<-Line(edge4[,3:4])
#create polygon from stream bank edges
edges <-rbind(edge3[,3:4],edge4[,3:4],edge3[1,3:4])
View(edges)
View(edges)
View(edge4)
order(edge4,decreasing=TRUE)
View(edge4)
edge4<-df[dim(edge4)[1]:1,]
edge3<-grid_csv %>% filter(J == 0)
edge4<-grid_csv %>% filter(J == max(grid_csv[,2]))
edge4<-df[dim(edge4)[1]:1,]
edge4<-edge4[dim(edge4)[1]:1,]
View(edge4)
edges <-rbind(edge3[,3:4],edge4[,3:4],edge3[1,3:4])
Polygon(edges)
testpoly <- Polygon(edges)
plot(testpoly)
spplot(testpoly)
library("maptools", lib.loc="U:/R/win-library/3.4")
install.packages("ggplot2")
install.packages("plyr")
fname = "U:\\iRIC tutorials\\outputs\\asciitest1.vtk"
readAsciiGrid(fname,plot.image = TRUE)
fname = "U:\\iRIC tutorials\\outputs\\asciitest1.vtk"
readAsciiGrid(fname)
plot(testpoly)
install.packages("dismo")
grid_xy <- grid_csv[,3:4]
vor_grid <- voronoi(grid_xy)
library("dismo", lib.loc="U:/R/win-library/3.4")
vor_grid <- voronoi(grid_xy)
install.packages("deldir")
library("deldir", lib.loc="U:/R/win-library/3.4")
grid_xy <- grid_csv[,3:4]
vor_grid <- deldir(grid_xy)
vor_grid <- deldir(grid_xy,plotit = TRUE)
library("dismo", lib.loc="U:/R/win-library/3.4")
grid_xy <- grid_csv[,3:4]
vor_grid <- voronoi(grid_xy)
plot(vor_grid)
gridcut <- intersect(vor_grid,testpoly)
library("sp", lib.loc="U:/R/win-library/3.4")
install.packages("rgeos")
packages <-c("data.table","raster","rgdal","shapefiles",
"gstat","sp","dplyr","gtools","maptools","deldir","dismo","rgeos")
require(packages)
lapply(packages,require,character.only=TRUE)
gridcut <- gIntersection(vor_grid,testpoly,byid=FALSE,drop_lower_td = TRUE)
plot(gridcut)
proj4string(testpoly)
SpatialPolygons(testpoly)
sp.polygons(testpoly)
testpoly<-sp.polygons(testpoly)
edges <-rbind(edge3[,3:4],edge4[,3:4],edge3[1,3:4])
testpoly <- Polygon(edges)
extent(testpoly)
proj4string(testpoly)<-proj4string(vor_grid)
proj4string(vor_grid)
library("rgdal", lib.loc="U:/R/win-library/3.4")
library("maptools", lib.loc="U:/R/win-library/3.4")
library("sp", lib.loc="U:/R/win-library/3.4")
library("sf", lib.loc="U:/R/win-library/3.4")
gridcut <- gIntersection(vor_grid,testpoly,byid=FALSE,drop_lower_td = TRUE)
proj4string(testpoly)<-CRS(vor_grid)
crs(vor_grid)
ca<-aggregate(testpoly)
as_Spatial(testpoly)
intersect(vor_grid,testpoly)
raster:intersect(testpoly,vor_grid)
proj4string(testpoly)
testpoly <- Polygon(edges,hole=FALSE)
grid_xy <- grid_csv[,3:4]
vor_grid <- voronoi(grid_xy)
gridcut <- gIntersection(vor_grid,testpoly,byid=FALSE,drop_lower_td = TRUE)
plot(testpoly)
SpatialPolygonDataFrame(testpoly)
testpoly <- SpatialPolygons(list(Polygon(edges,hole=FALSE),1))
testpoly <- SpatialPolygons(Polygons(list(Polygon(edges,hole=FALSE),1)))
ps<-Polygons(list(testpoly),1)
sps<-SpatialPolygons(list(ps))
grid_xy <- grid_csv[,3:4]
vor_grid <- voronoi(grid_xy)
gridcut <- gIntersection(vor_grid,testpoly,byid=FALSE,drop_lower_td = TRUE)
plot(gridcut)
testpoly <- SpatialPolygons(list(Polygons(list(Polygon(edges,hole=FALSE),1))))
testpoly <- Polygons(list(Polygon(edges,hole=FALSE),1))
testpoly <- SpatialPolygons(list(testpoly))
testpoly <- Polygon(edges,hole=FALSE)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
grid_xy <- grid_csv[,3:4]
gridcut <- gIntersection(vor_grid,testpoly,byid=FALSE,drop_lower_td = TRUE)
plot(testpoly)
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
gridcut <- gIntersection(vor_grid,testpoly,byid=FALSE,drop_lower_td = TRUE)
plot(testpoly)
tritest<-gDelaunayTriangulation(grid_xy)
#import .tpo data
iricOutPath <- "U:\\iRIC tutorials\\outputs\\chris_results1_"
tpo_out <-fread(paste(iricOutPath,"Elevation",".tpo",sep = ""), header=FALSE, sep=",")
#create raster from .tpo
tpo_spdf <- SpatialPointsDataFrame(tpo_out[,c(1,2)],tpo_out[,3])
rast_hold <- raster()
tritest<-gDelaunayTriangulation(tpo_spdf)
plot(tritest)
simps<-gSimplify(ps)
simps<-gSimplify(ps,tol=0.0001)
edges <-rbind(edge3[,3:4],edge4[,3:4])
testpoly <- Polygon(edges)
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
gridcut <- gIntersection(vor_grid,testpoly,byid=FALSE,drop_lower_td = TRUE)
plot(testpoly)
View(edges)
View(edge3)
View(edge4)
View(edges)
View(edges)
View(edges)
View(edge3)
View(edge4)
remove.duplicates(edges)
distinct(edges)
View(edges)
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
plot(testpoly)
gSimplify(testpoly)
simps<-gSimplify(testpoly,tol=0.0001)
plot(simps)
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
spoly <-gSimplify(testpoly, tol=0.0001)
grid_xy <- grid_csv[,3:4]
vor_grid <- voronoi(grid_xy)
gridcut <- gIntersection(vor_grid,spoly,byid=FALSE,drop_lower_td = TRUE)
plot(spoly)
plot(gridcut)
gridcut <- gIntersection(spoly,grid_xy,byid=FALSE,drop_lower_td = TRUE)
gridcut <- gIntersection(grid_xy,spoly,byid=FALSE,drop_lower_td = TRUE)
plot(gridcut)
# Extracting the shape of the computational grid in iRIC to define the study area in R
# updated 12/14/18
#load required packages
packages <-c("data.table","raster","rgdal","shapefiles",
"gstat","sp","dplyr","gtools","maptools","deldir","dismo","rgeos")
require(packages)
lapply(packages,require,character.only=TRUE)
#import iRIC calculation grid .csv
iricOutPath <- "U:\\iRIC tutorials\\outputs\\"
grid_csv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-grid_csv %>% filter(J == 0)
edge4<-grid_csv %>% filter(J == max(grid_csv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
spoly <-gSimplify(testpoly, tol=0.0001)
#create
grid_xy <- grid_csv[,3:4]
vor_grid <- voronoi(grid_xy)
gridcut <- gIntersection(grid_xy,spoly,byid=FALSE,drop_lower_td = TRUE)
plot(spoly)
proj4string(vor_grid)
proj4string(spoly)
class(spoly)
class(vor_grid)
class(grid_xy)
gridcut <- gIntersection(vor_grid,spoly,byid=FALSE,drop_lower_td = TRUE)
plot(gridcut)
gridcut <- gIntersection(spoly,gridcut,byid=FALSE,drop_lower_td = TRUE)
plot(gridcut)
gridcut <- gIntersection(spoly,gridcut,byid=FALSE,drop_lower_td = FALSE)
plot(gridcut)
gridcut <- gIntersection(spoly,gridcut,byid=FALSE,drop_lower_td = FALSE)
plot(gridcut)
plot(vor_grid)
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
spoly <-gSimplify(testpoly, tol=0.0001)
#intersect grid outline and voronoi polygons
gridxy <- gridcsv[,3:4]
vorgrid <- voronoi(gridxy)
gridcut <- gIntersection(spoly,gridcut,byid=FALSE,drop_lower_td = FALSE)
intersect(vorgid,gridxy)
intersect(vorgrid,gridxy)
View(gridcsv)
View(gridxy)
raster::intersect(vorgrid,gridxy)
extent(gridxy)
extent(vor_grid)
extent(grid_xy)
extent(spoly)
raster::intersect(vorgrid,gridcut)
gridcut <- gIntersection(vorgrid,spoly,byid=FALSE,drop_lower_td=FALSE)
plot(gridcut)
#intersect
test1<-intersect(vorgrid,spoly)
plot(test1)
class(grid_xy)
View(gridcsv)
p <- matrix(c(17, 42, 85, 70, 19, 53, 26, 84, 84, 46, 48, 85, 4, 95, 48, 54, 66, 74, 50, 48,
28, 73, 38, 56, 43, 29, 63, 22, 46, 45, 7, 60, 46, 34, 14, 51, 70, 31, 39, 26), ncol=2)
v <- voronoi(p)
v
gridxy <- gridcsv[,2:4]
test2<-SpatialPointsDataFrame(gridxy[,2:3],data=gridxy[,1])
vortest <-voronoi(test2)
ssplot(vortest, col.regions=gray(seq(0,10,310)))
spplot(vortest, col.regions=gray(seq(0,10,310)))
spplot(vortest, col.regions=blue(seq(0,310,62)))
spplot(vortest, col.regions=gray(seq(0,310,62)))
spplot(vortest, col.regions=gray(seq(0,1,62)))
#import iRIC calculation grid .csv
iricOutPath <- "U:\\iRIC tutorials\\outputs\\"
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
spoly <-gSimplify(testpoly, tol=0.0001)
#intersect grid outline and voronoi polygons
gridxy <- gridcsv[,2:4]
vorgrid <- voronoi(gridxy)
gridcut <- intersect(vorgrid,spoly)
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
spoly <-gSimplify(testpoly, tol=0.0001)
#intersect grid outline and voronoi polygons
gridxy <- gridcsv[,3:4]
vorgrid <- voronoi(gridxy)
gridcut <- intersect(vorgrid,spoly
)
plot(gridcut)
#import .tpo data
iricOutPath <- "U:\\iRIC tutorials\\outputs\\chris_results1_"
tpoOut <-fread(paste(iricOutPath,"Elevation",".tpo",sep = ""), header=FALSE, sep=",")
#create raster from .tpo
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,c(1,2)],tpoOut[,3])
rastHold <- raster()
extent(rastHold)<-extent(tpoSpdf)
#iRIC sample data missing CRS info
crs(rastHold)<-proj4string(tpoSpdf)
##interpolate raster to fill holes: nearest neighbor
gs<-gstat(formula=tpoSpdf$V3~1,data=tpoSpdf)
idwOut<-interpolate(rastHold,gs)
plot(idwOut)
rastXYZ <- rasterize(tpoSpdf,rastHold,tpoSpdf$V3)
plot(rastXYZ)
gridxy <- SpatialPointsDataFrame(gridcsv[,3:4],gridcsv[,2])
vorgrid <- voronoi(gridxy)
gridcut <- intersect(vorgrid,gridBound)
gridBound <-gSimplify(epoly, tol=0.0001)
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
epoly <- SpatialPolygons(list(epoly))
gridBound <-gSimplify(epoly, tol=0.0001)
gridcut <- intersect(vorgrid,gridBound)
plot(gridcut)
plot(gridxy)
spplot(gridcut,J,colorkey=TRUE)
spplot(gridcut,gricut$J,colorkey=TRUE)
spplot(gridcut,gridcut$J,colorkey=TRUE)
spplot(gridcut,gridcut[,1],colorkey=TRUE)
spplot(gridcut,zcol=gridcut[,1],colorkey=TRUE)
spplot(gridcut,colorkey=TRUE)
plot(tpoSpdf)
head(tpoOut)
plot(epoly)
plot(gridBound)
#import .tpo data
iricOutPath <- "U:\\iRIC tutorials\\outputs\\"
tpoOut <-fread(paste(iricOutPath,"chris_results1_Elevation",".tpo",sep = ""), header=FALSE, sep=",")
#create raster from .tpo
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,c(1,2)],tpoOut[,3])
rastHold <- raster()
extent(rastHold)<-extent(tpoSpdf)
#iRIC sample data missing CRS info
crs(rastHold)<-proj4string(tpoSpdf)
#intersect grid outline and voronoi polygons
get.grid(iricOutPath)
vorgrid <- voronoi(tpoSpdf)
gridcut <- intersect(vorgrid,gridBound)
spplot(gridcut,colorkey=TRUE)
source("get.grid.R")
get.grid(iricOutPath)
do.call(get.grid, iricOutPath)
call(get.grid)
#begin function
get.grid <- function(iricOutPath){
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
gridBound <- SpatialPolygons(list(epoly))
return(gridBound)
}
get.grid(iricOutPath)
vorgrid <- voronoi(tpoSpdf)
gridcut <- intersect(vorgrid,gridBound)
spplot(gridcut,colorkey=TRUE)
library("deldir", lib.loc="U:/R/win-library/3.4")
library("dismo", lib.loc="U:/R/win-library/3.4")
vorgrid <- voronoi(tpoSpdf)
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#import iRIC calculation grid .csv
iricOutPath <- "U:\\iRIC tutorials\\outputs\\"
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
gridBound <- SpatialPolygons(list(epoly))
return(gridBound)
#begin function
get.grid <- function(iricOutPath){
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
gridBound <- SpatialPolygons(list(epoly))
return(gridBound)
} #end get.grid function
#intersect grid outline and voronoi polygons
gridxy <- SpatialPointsDataFrame(gridcsv[,3:4],gridcsv[,2])
vorgrid <- voronoi(gridxy)
tpoOut <-fread(paste(iricOutPath,"chris_results1_Elevation",".tpo",sep = ""), header=FALSE, sep=",")
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,c(1,2)],tpoOut[,3])
class(gridcsv)
class(tpoSpdf)
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,1:3])
#create raster from .tpo
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,1:2],tpoOut[,3])
vorgrid <- voronoi(tpoSpdf)
tpoSpdf[,1:2]
tpoSpdf$V3
gridxy[,3]
gridxy$J
voronoi(tpoSpdf)
deldir(tpoSpdf)
deldir(gridxy)
View(tpoOut)
View(gridcsv)
names(tpoSpdf) <-c("X","Y","Z")
View(gridcsv)
View(tpoOut)
names(tpoOut) <-c("X","Y","Z")
View(tpoOut)
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,1:2],tpoOut[,3])
vorgrid <- voronoi(tpoSpdf)
.libpaths()
.libPaths()
myPaths <- .libPaths()   # get the paths
myPaths <- c(myPaths[2], myPaths[1])  # switch them
.libPaths(myPaths)  # reassign them
# Set Inputs
wd <- "C:/Users/epassero/Desktop/VRDSS/verde-refdss/"
setwd(wd)
source("get.results.R")
source("iric.process.smr.R")
source("bricks.rc.R")
source("by.substrate.R")
source("brick.2.spdf.R")
source("effective.area.R")
source("build.tables.eff.R")
source("save.polys.eff.R")
source("build.tables.tot.R")
source("save.polys.tot.R")
source("inspect.hydro.R")
source("interp.table.R")
source("interp.plot.R")
# Function: This script serves as the master script that controls which functions are run and what inputs are used for finding suitable fish habitat
#         It will later be converted to the script that controls the Shiny App.
# Last edited by Elaina Passero on 04/4/19
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis","ggplot2","data.table","dpylr","plotly")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
# load the installed libraries in the packages list
lapply(packages,library,character.only=TRUE)
# Set Inputs
wd <- "C:/Users/epassero/Desktop/VRDSS/verde-refdss/"
#wd <- "/Users/Morrison/Documents/Active Research Projects/Verde REFDSS/verde-refdss/" # Set path to local repository
setwd(wd)
habMets <- list("Depth","Velocity..magnitude.") #Variables from iRIC calculation result used for habitat analysis
species <- "fakefish"
lifestages <- list("adult","juvenile") #lifestages from oldest to youngest; must match order in HSC table
reachName <- "Sample" # 1Beasley or Sample
DEM <- "smrf_DEM_v241.tif" # Name of DEM used in iRIC: VerdeBeasley1Elev.tif or smrf_DEM_v241.tif
disunit <- "cms" #units of discharge
# Options: Currently this is only set up to run with the Sample reach
CheckSub <- 1 # 1 (Yes) or 0 (No). Choose whether or not to check substrate conditions as part of suitable habitat
CalcEffArea <- 1 # 1 (Yes) or 0 (No). Choose whether or not to calculate effective habitat area
# Load functions
source("get.results.R")
source("iric.process.smr.R")
source("bricks.rc.R")
source("by.substrate.R")
source("brick.2.spdf.R")
source("effective.area.R")
source("build.tables.eff.R")
source("save.polys.eff.R")
source("build.tables.tot.R")
source("save.polys.tot.R")
source("inspect.hydro.R")
source("interp.table.R")
source("interp.plot.R")
# Run functions
## Format result CSVs and get list of discharges
holdList <- get.results(wd,reachName,disunit)
csvList <- holdList$csvList
modeled_q <- holdList$modeled_q
rm(holdList)
## Convert iRIC outputs to rasterBricks by variable
iricValRast <- list()
iricValRast <- lapply(habMets, function(a) iric.process.smr(a,csvList,wd,DEM,reachName))
names(iricValRast) <-habMets
rm(csvList)
## Reclassify Bricks with hydraulic and substrate HSC by lifestage
hsc_allages<-fread(paste(wd,species,"_hsc",".csv",sep = ""), header=TRUE, sep=",")
if(CheckSub == "1"){sub_allages<-fread(paste(wd,species,"_substrate",".csv",sep=""),header=TRUE, sep = ",",data.table = FALSE)} # load substrate requirements
goodHabList <- list() # list that will hold suitable hydraulic habitat by lifestage
for(b in 1:length(lifestages)){
hsc <- hsc_allages[b] # creates HSC table for current lifestage
goodHabList[[b]] <- bricks.rc(iricValRast,hsc,habMets)
if(CheckSub == "1"){
subTab <- sub_allages[,b] # creates table of substrate for current lifestage
hhList <- goodHabList[[b]] # holds rasters of area for current lifestage
goodHabList[[b]] <- by.substrate(hhList,subTab)
} # end of if statement
} # end of for loop
names(goodHabList) <- lifestages # list of Bricks by lifestage
## Total available habitat area by lifestage
goodPolyList <- lapply(goodHabList, function(c) brick.2.spdf(c))
rm(goodHabList)
## Effective habitat area
if (CalcEffArea == 1){
### Calculate effective habitat area
effAreaList <- lapply(lifestages,function(e) effective.area(e,goodPolyList))
names(effAreaList) <- lifestages
### Construct Area-Lookup Tables
areaLookTab <- lapply(lifestages, function(j) build.tables.eff(j,goodPolyList,effAreaList,modeled_q)) # data frame of total available and effective area
names(areaLookTab) <- lifestages
polyTab <- lapply(lifestages, function(m) save.polys.eff(m, goodPolyList, effAreaList, modeled_q))# data frame of spatial polygons
names(polyTab) <- lifestages
} else{ ## Total available habitat area
### Construct Area-Lookup Tables
areaLookTab <- lapply(lifestages, function(p) build.tables.tot(p,goodPolyList,totAreaList,modeled_q)) # data frame of total available area
names(areaLookTab) <- lifestages
polyTab <- lapply(lifestages, function(r) save.polys.tot(r, goodPolyList, effAreaList, modeled_q)) # data frame of spatial polygons
names(polyTab) <- lifestages
}
## Read in hydrograph
hydrograph <- na.omit(fread(paste(wd,reachName,"_hydrograph",".csv",sep=""),header=TRUE, sep = ",",data.table=FALSE))
hydrograph$date <- as.Date(hydrograph$date, format="%m/%d/%Y")
## Generate Interpolated Discharge-Area Lookup Tables from Hydrograph and Regression
interTab <- lapply(lifestages, function(t) interp.table(t,hydrograph,areaLookTab))
names(interTab) <- lifestages
## Generate and view plots of total area through the hydrograph
inter.plots <- unlist(lapply(lifestages, function(t) interp.plot(t,interTab)))
head(inter.plots)
