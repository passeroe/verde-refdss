#plot(s)
rerast <-raster(nrow=360,ncol=720)
resample(shp2rast, rerast, method="bilinear")
plot(shp2rast)
rerast <-raster(nrow=360,ncol=720)
newrast<-resample(shp2rast, rerast, method="bilinear")
newrast<-resample(shp2rast, rerast, method="ngb")
newrast<-disaggregate(shp2rast, fact=3, method='bilinear')
plot(newrast)
newrast<-disaggregate(shp2rast, fact=5, method='bilinear')
plot(newrast)
extent(rast_test) <-extent(input_sfile)
shp2rast <- rasterize(input_sfile,rast_test,depth)
plot(shp2rast)
newrast<-disaggregate(shp2rast, fact=10, method='bilinear')
plot(newrast)
# rasterize shapefile
extent(rast_test) <-extent(input_sfile)
shp2rast <- rasterize(input_sfile,rast_test,depth)
plot(shp2rast)
#disaggregate to create higher resolution grid
newrast<-disaggregate(shp2rast, fact=5, method='bilinear')
plot(newrast)
rast_test <- raster(ncol=90,nrow=180)
# rasterize shapefile
extent(rast_test) <-extent(input_sfile)
shp2rast <- rasterize(input_sfile,rast_test,depth)
plot(shp2rast)
#disaggregate to create higher resolution grid
newrast<-disaggregate(shp2rast, fact=5, method='bilinear')
plot(newrast)
# rasterize shapefile
rast_test2 <- raster(ncol=120,nrow=240)
extent(rast_test2) <-extent(input_sfile)
shp2rast <- rasterize(input_sfile,rast_test2,depth)
plot(shp2rast)
#disaggregate to create higher resolution grid
newrast<-disaggregate(shp2rast, fact=5, method='bilinear')
plot(newrast)
# rasterize shapefile
#rast_test2 <- raster(ncol=120,nrow=240)
rast_test2 <- raster()
extent(rast_test2) <-extent(input_sfile)
shp2rast <- rasterize(input_sfile,rast_test2,depth)
plot(shp2rast)
#disaggregate to create higher resolution grid
newrast<-disaggregate(shp2rast, fact=5, method='ngb')
plot(newrast)
rast_test2 <- raster()
extent(rast_test2) <-extent(input_sfile)
shp2rast <- rasterize(input_sfile,rast_test2,depth)
plot(shp2rast)
#disaggregate to create higher resolution grid
newrast<-disaggregate(shp2rast, fact=5)
plot(newrast)
#load required packages
packages <-c("data.table","raster","rgdal","shapefiles","gstat","sp","dplyr","gtools")
require(packages)
lapply(packages,require,character.only=TRUE)
#import iRIC calculation grid .csv
iricOutPath <- "U:\\iRIC tutorials\\outputs\\"
grid_csv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
#edge1<-grid_csv %>% filter(I == 0)
#edge2<-grid_csv %>% filter(I == max(grid_csv[,1]))
edge3<-as.matrix(grid_csv %>% filter(J == 0))
edge4<-as.matrix(grid_csv %>% filter(J == max(grid_csv[,2])))
#create edge lines from X,Y values
#e1Line<-Line(edge1[,3:4])
#e2Line<-Line(edge2[,3:4])
#e3Line<-Line(edge3[,3:4])
#e4Line<-Line(edge4[,3:4])
#create polygon from stream bank edges
edges <-rbind(edge3[,3:4],edge4[,3:4],edge3[1,3:4])
View(edges)
View(edges)
View(edge4)
order(edge4,decreasing=TRUE)
View(edge4)
edge4<-df[dim(edge4)[1]:1,]
edge3<-grid_csv %>% filter(J == 0)
edge4<-grid_csv %>% filter(J == max(grid_csv[,2]))
edge4<-df[dim(edge4)[1]:1,]
edge4<-edge4[dim(edge4)[1]:1,]
View(edge4)
edges <-rbind(edge3[,3:4],edge4[,3:4],edge3[1,3:4])
Polygon(edges)
testpoly <- Polygon(edges)
plot(testpoly)
spplot(testpoly)
library("maptools", lib.loc="U:/R/win-library/3.4")
install.packages("ggplot2")
install.packages("plyr")
fname = "U:\\iRIC tutorials\\outputs\\asciitest1.vtk"
readAsciiGrid(fname,plot.image = TRUE)
fname = "U:\\iRIC tutorials\\outputs\\asciitest1.vtk"
readAsciiGrid(fname)
plot(testpoly)
install.packages("dismo")
grid_xy <- grid_csv[,3:4]
vor_grid <- voronoi(grid_xy)
library("dismo", lib.loc="U:/R/win-library/3.4")
vor_grid <- voronoi(grid_xy)
install.packages("deldir")
library("deldir", lib.loc="U:/R/win-library/3.4")
grid_xy <- grid_csv[,3:4]
vor_grid <- deldir(grid_xy)
vor_grid <- deldir(grid_xy,plotit = TRUE)
library("dismo", lib.loc="U:/R/win-library/3.4")
grid_xy <- grid_csv[,3:4]
vor_grid <- voronoi(grid_xy)
plot(vor_grid)
gridcut <- intersect(vor_grid,testpoly)
library("sp", lib.loc="U:/R/win-library/3.4")
install.packages("rgeos")
packages <-c("data.table","raster","rgdal","shapefiles",
"gstat","sp","dplyr","gtools","maptools","deldir","dismo","rgeos")
require(packages)
lapply(packages,require,character.only=TRUE)
gridcut <- gIntersection(vor_grid,testpoly,byid=FALSE,drop_lower_td = TRUE)
plot(gridcut)
proj4string(testpoly)
SpatialPolygons(testpoly)
sp.polygons(testpoly)
testpoly<-sp.polygons(testpoly)
edges <-rbind(edge3[,3:4],edge4[,3:4],edge3[1,3:4])
testpoly <- Polygon(edges)
extent(testpoly)
proj4string(testpoly)<-proj4string(vor_grid)
proj4string(vor_grid)
library("rgdal", lib.loc="U:/R/win-library/3.4")
library("maptools", lib.loc="U:/R/win-library/3.4")
library("sp", lib.loc="U:/R/win-library/3.4")
library("sf", lib.loc="U:/R/win-library/3.4")
gridcut <- gIntersection(vor_grid,testpoly,byid=FALSE,drop_lower_td = TRUE)
proj4string(testpoly)<-CRS(vor_grid)
crs(vor_grid)
ca<-aggregate(testpoly)
as_Spatial(testpoly)
intersect(vor_grid,testpoly)
raster:intersect(testpoly,vor_grid)
proj4string(testpoly)
testpoly <- Polygon(edges,hole=FALSE)
grid_xy <- grid_csv[,3:4]
vor_grid <- voronoi(grid_xy)
gridcut <- gIntersection(vor_grid,testpoly,byid=FALSE,drop_lower_td = TRUE)
plot(testpoly)
SpatialPolygonDataFrame(testpoly)
testpoly <- SpatialPolygons(list(Polygon(edges,hole=FALSE),1))
testpoly <- SpatialPolygons(Polygons(list(Polygon(edges,hole=FALSE),1)))
ps<-Polygons(list(testpoly),1)
sps<-SpatialPolygons(list(ps))
grid_xy <- grid_csv[,3:4]
vor_grid <- voronoi(grid_xy)
gridcut <- gIntersection(vor_grid,testpoly,byid=FALSE,drop_lower_td = TRUE)
plot(gridcut)
testpoly <- SpatialPolygons(list(Polygons(list(Polygon(edges,hole=FALSE),1))))
testpoly <- Polygons(list(Polygon(edges,hole=FALSE),1))
testpoly <- SpatialPolygons(list(testpoly))
testpoly <- Polygon(edges,hole=FALSE)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
grid_xy <- grid_csv[,3:4]
gridcut <- gIntersection(vor_grid,testpoly,byid=FALSE,drop_lower_td = TRUE)
plot(testpoly)
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
gridcut <- gIntersection(vor_grid,testpoly,byid=FALSE,drop_lower_td = TRUE)
plot(testpoly)
tritest<-gDelaunayTriangulation(grid_xy)
#import .tpo data
iricOutPath <- "U:\\iRIC tutorials\\outputs\\chris_results1_"
tpo_out <-fread(paste(iricOutPath,"Elevation",".tpo",sep = ""), header=FALSE, sep=",")
#create raster from .tpo
tpo_spdf <- SpatialPointsDataFrame(tpo_out[,c(1,2)],tpo_out[,3])
rast_hold <- raster()
tritest<-gDelaunayTriangulation(tpo_spdf)
plot(tritest)
simps<-gSimplify(ps)
simps<-gSimplify(ps,tol=0.0001)
edges <-rbind(edge3[,3:4],edge4[,3:4])
testpoly <- Polygon(edges)
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
gridcut <- gIntersection(vor_grid,testpoly,byid=FALSE,drop_lower_td = TRUE)
plot(testpoly)
View(edges)
View(edge3)
View(edge4)
View(edges)
View(edges)
View(edges)
View(edge3)
View(edge4)
remove.duplicates(edges)
distinct(edges)
View(edges)
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
plot(testpoly)
gSimplify(testpoly)
simps<-gSimplify(testpoly,tol=0.0001)
plot(simps)
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
spoly <-gSimplify(testpoly, tol=0.0001)
grid_xy <- grid_csv[,3:4]
vor_grid <- voronoi(grid_xy)
gridcut <- gIntersection(vor_grid,spoly,byid=FALSE,drop_lower_td = TRUE)
plot(spoly)
plot(gridcut)
gridcut <- gIntersection(spoly,grid_xy,byid=FALSE,drop_lower_td = TRUE)
gridcut <- gIntersection(grid_xy,spoly,byid=FALSE,drop_lower_td = TRUE)
plot(gridcut)
# Extracting the shape of the computational grid in iRIC to define the study area in R
# updated 12/14/18
#load required packages
packages <-c("data.table","raster","rgdal","shapefiles",
"gstat","sp","dplyr","gtools","maptools","deldir","dismo","rgeos")
require(packages)
lapply(packages,require,character.only=TRUE)
#import iRIC calculation grid .csv
iricOutPath <- "U:\\iRIC tutorials\\outputs\\"
grid_csv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-grid_csv %>% filter(J == 0)
edge4<-grid_csv %>% filter(J == max(grid_csv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
spoly <-gSimplify(testpoly, tol=0.0001)
#create
grid_xy <- grid_csv[,3:4]
vor_grid <- voronoi(grid_xy)
gridcut <- gIntersection(grid_xy,spoly,byid=FALSE,drop_lower_td = TRUE)
plot(spoly)
proj4string(vor_grid)
proj4string(spoly)
class(spoly)
class(vor_grid)
class(grid_xy)
gridcut <- gIntersection(vor_grid,spoly,byid=FALSE,drop_lower_td = TRUE)
plot(gridcut)
gridcut <- gIntersection(spoly,gridcut,byid=FALSE,drop_lower_td = TRUE)
plot(gridcut)
gridcut <- gIntersection(spoly,gridcut,byid=FALSE,drop_lower_td = FALSE)
plot(gridcut)
gridcut <- gIntersection(spoly,gridcut,byid=FALSE,drop_lower_td = FALSE)
plot(gridcut)
plot(vor_grid)
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
spoly <-gSimplify(testpoly, tol=0.0001)
#intersect grid outline and voronoi polygons
gridxy <- gridcsv[,3:4]
vorgrid <- voronoi(gridxy)
gridcut <- gIntersection(spoly,gridcut,byid=FALSE,drop_lower_td = FALSE)
intersect(vorgid,gridxy)
intersect(vorgrid,gridxy)
View(gridcsv)
View(gridxy)
raster::intersect(vorgrid,gridxy)
extent(gridxy)
extent(vor_grid)
extent(grid_xy)
extent(spoly)
raster::intersect(vorgrid,gridcut)
gridcut <- gIntersection(vorgrid,spoly,byid=FALSE,drop_lower_td=FALSE)
plot(gridcut)
#intersect
test1<-intersect(vorgrid,spoly)
plot(test1)
class(grid_xy)
View(gridcsv)
p <- matrix(c(17, 42, 85, 70, 19, 53, 26, 84, 84, 46, 48, 85, 4, 95, 48, 54, 66, 74, 50, 48,
28, 73, 38, 56, 43, 29, 63, 22, 46, 45, 7, 60, 46, 34, 14, 51, 70, 31, 39, 26), ncol=2)
v <- voronoi(p)
v
gridxy <- gridcsv[,2:4]
test2<-SpatialPointsDataFrame(gridxy[,2:3],data=gridxy[,1])
vortest <-voronoi(test2)
ssplot(vortest, col.regions=gray(seq(0,10,310)))
spplot(vortest, col.regions=gray(seq(0,10,310)))
spplot(vortest, col.regions=blue(seq(0,310,62)))
spplot(vortest, col.regions=gray(seq(0,310,62)))
spplot(vortest, col.regions=gray(seq(0,1,62)))
#import iRIC calculation grid .csv
iricOutPath <- "U:\\iRIC tutorials\\outputs\\"
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
spoly <-gSimplify(testpoly, tol=0.0001)
#intersect grid outline and voronoi polygons
gridxy <- gridcsv[,2:4]
vorgrid <- voronoi(gridxy)
gridcut <- intersect(vorgrid,spoly)
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
testpoly <- Polygon(edges)
testpoly <- Polygons(list(testpoly),1)
testpoly <- SpatialPolygons(list(testpoly))
spoly <-gSimplify(testpoly, tol=0.0001)
#intersect grid outline and voronoi polygons
gridxy <- gridcsv[,3:4]
vorgrid <- voronoi(gridxy)
gridcut <- intersect(vorgrid,spoly
)
plot(gridcut)
#import .tpo data
iricOutPath <- "U:\\iRIC tutorials\\outputs\\chris_results1_"
tpoOut <-fread(paste(iricOutPath,"Elevation",".tpo",sep = ""), header=FALSE, sep=",")
#create raster from .tpo
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,c(1,2)],tpoOut[,3])
rastHold <- raster()
extent(rastHold)<-extent(tpoSpdf)
#iRIC sample data missing CRS info
crs(rastHold)<-proj4string(tpoSpdf)
##interpolate raster to fill holes: nearest neighbor
gs<-gstat(formula=tpoSpdf$V3~1,data=tpoSpdf)
idwOut<-interpolate(rastHold,gs)
plot(idwOut)
rastXYZ <- rasterize(tpoSpdf,rastHold,tpoSpdf$V3)
plot(rastXYZ)
gridxy <- SpatialPointsDataFrame(gridcsv[,3:4],gridcsv[,2])
vorgrid <- voronoi(gridxy)
gridcut <- intersect(vorgrid,gridBound)
gridBound <-gSimplify(epoly, tol=0.0001)
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
epoly <- SpatialPolygons(list(epoly))
gridBound <-gSimplify(epoly, tol=0.0001)
gridcut <- intersect(vorgrid,gridBound)
plot(gridcut)
plot(gridxy)
spplot(gridcut,J,colorkey=TRUE)
spplot(gridcut,gricut$J,colorkey=TRUE)
spplot(gridcut,gridcut$J,colorkey=TRUE)
spplot(gridcut,gridcut[,1],colorkey=TRUE)
spplot(gridcut,zcol=gridcut[,1],colorkey=TRUE)
spplot(gridcut,colorkey=TRUE)
plot(tpoSpdf)
head(tpoOut)
plot(epoly)
plot(gridBound)
#import .tpo data
iricOutPath <- "U:\\iRIC tutorials\\outputs\\"
tpoOut <-fread(paste(iricOutPath,"chris_results1_Elevation",".tpo",sep = ""), header=FALSE, sep=",")
#create raster from .tpo
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,c(1,2)],tpoOut[,3])
rastHold <- raster()
extent(rastHold)<-extent(tpoSpdf)
#iRIC sample data missing CRS info
crs(rastHold)<-proj4string(tpoSpdf)
#intersect grid outline and voronoi polygons
get.grid(iricOutPath)
vorgrid <- voronoi(tpoSpdf)
gridcut <- intersect(vorgrid,gridBound)
spplot(gridcut,colorkey=TRUE)
source("get.grid.R")
get.grid(iricOutPath)
do.call(get.grid, iricOutPath)
call(get.grid)
#begin function
get.grid <- function(iricOutPath){
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
gridBound <- SpatialPolygons(list(epoly))
return(gridBound)
}
get.grid(iricOutPath)
vorgrid <- voronoi(tpoSpdf)
gridcut <- intersect(vorgrid,gridBound)
spplot(gridcut,colorkey=TRUE)
library("deldir", lib.loc="U:/R/win-library/3.4")
library("dismo", lib.loc="U:/R/win-library/3.4")
vorgrid <- voronoi(tpoSpdf)
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#import iRIC calculation grid .csv
iricOutPath <- "U:\\iRIC tutorials\\outputs\\"
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
gridBound <- SpatialPolygons(list(epoly))
return(gridBound)
#begin function
get.grid <- function(iricOutPath){
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
gridBound <- SpatialPolygons(list(epoly))
return(gridBound)
} #end get.grid function
#intersect grid outline and voronoi polygons
gridxy <- SpatialPointsDataFrame(gridcsv[,3:4],gridcsv[,2])
vorgrid <- voronoi(gridxy)
tpoOut <-fread(paste(iricOutPath,"chris_results1_Elevation",".tpo",sep = ""), header=FALSE, sep=",")
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,c(1,2)],tpoOut[,3])
class(gridcsv)
class(tpoSpdf)
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,1:3])
#create raster from .tpo
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,1:2],tpoOut[,3])
vorgrid <- voronoi(tpoSpdf)
tpoSpdf[,1:2]
tpoSpdf$V3
gridxy[,3]
gridxy$J
voronoi(tpoSpdf)
deldir(tpoSpdf)
deldir(gridxy)
View(tpoOut)
View(gridcsv)
names(tpoSpdf) <-c("X","Y","Z")
View(gridcsv)
View(tpoOut)
names(tpoOut) <-c("X","Y","Z")
View(tpoOut)
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,1:2],tpoOut[,3])
vorgrid <- voronoi(tpoSpdf)
.libpaths()
.libPaths()
myPaths <- .libPaths()   # get the paths
myPaths <- c(myPaths[2], myPaths[1])  # switch them
.libPaths(myPaths)  # reassign them
# Function: This script serves as the master script that controls which functions are run and what inputs are used for finding suitable fish habitat
#         It will later be converted to the script that controls the Shiny App.
# Last edited by Elaina Passero on 02/22/19
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis","ggplot2","data.table","dpylr")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
# load the installed libraries in the packages list
lapply(packages,library,character.only=TRUE)
# Set Inputs
wd <- "C:\\Users\\epassero\\Desktop\\VRDSS\\verde-refdss\\" # Set path to local repository
habMets <- list("Depth","Velocity..magnitude") #Variables from iRIC calculation result used for habitat analysis
species <- "fakefish"
lifestages <- list("adult","juvenile") #lifestages from oldest to youngest; must match order in HSC table
reachName <- "Sample" # 1Beasley or Sample
DEM <- "smrf_DEM_v241.tif" # Name of DEM used in iRIC: VerdeBeasley1Elev.tif or smrf_DEM_v241.tif
# Options: Currently this is only set up to run with the Sample reach
CheckSub <- 1 # 1 (Yes) or 0 (No). Choose whether or not to check substrate conditions as part of suitable habitat
# Load functions
source(paste(wd,"get.results.R",sep="\\"))
source(paste(wd,"iric.process.smr.R",sep="\\"))
source(paste(wd, "stacks.rc.R",sep="\\"))
source(paste(wd, "by.substrate.R",sep="\\"))
source(paste(wd, "brick.2.spdf.R",sep="\\"))
# Run functions
## Convert iRIC outputs to rasterStacks by variable
holdList <- get.results(wd,reachName)
csvList <- holdList$csvList
modeled_q <- holdList$modeled_q
iricValRast <- mapply(iric.process.smr,habMets,c(wd,DEM,reachName,csvList))
iricValRast <- mapply(iric.process.smr,habMets,csvList, MoreArgs = c(wd,DEM,reachName)))
iricValRast <- mapply(iric.process.smr,habMets,csvList, MoreArgs = c(wd,DEM,reachName))
iricValRast <- mapply(iric.process.smr,habMets,csvList, MoreArgs = list(wd,DEM,reachName))
source(paste(wd,"iric.process.smr.R",sep="\\"))
iricValRast <- mapply(iric.process.smr,habMets,csvList, MoreArgs = list(wd,DEM,reachName))
source(paste(wd,"iric.process.smr.R",sep="\\"))
iricValRast <- mapply(iric.process.smr,habMets,csvList, MoreArgs = list(wd,DEM,reachName))
