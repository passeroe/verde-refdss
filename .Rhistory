facet_wrap(vars(scene),dir = "v")+
{if(length(lifestages)>1) scale_alpha_discrete(range = c(1,0.35))}+
{if(length(lifestages)==1) scale_alpha_discrete(guide="none",range = c(1,1))}+
xlab(element_blank())+
ylab("% Change in Habitat Area")
ggplot(data = veg_summary_tab, aes(x = reorder(group,per_chg), y = per_chg, fill = criteria))+
theme_few()+
scale_fill_brewer(palette = "Set1")+
geom_bar(stat = "identity")+
coord_flip()+
theme(legend.position = "right",
text=element_text(size=14,face = "bold",color = "black"),
axis.text.x = element_text(colour = "black",face="plain"),
axis.text.y = element_text(colour = "black",face="plain"))+
facet_wrap(vars(scene),dir = "v")+
xlab(element_blank())+
ylab("% Change in Habitat Area")
?facet_wrap
ggplot(data = veg_summary_tab, aes(x = reorder(group,per_chg), y = per_chg, fill = criteria))+
theme_few()+
scale_fill_brewer(palette = "Set1")+
geom_bar(stat = "identity")+
coord_flip()+
theme(legend.position = "right",
text=element_text(size=14,face = "bold",color = "black"),
axis.text.x = element_text(colour = "black",face="plain"),
axis.text.y = element_text(colour = "black",face="plain"))+
facet_wrap(vars(scene),dir = "v",labeller = c("Scenario A","Scenario B"))+
xlab(element_blank())+
ylab("% Change in Habitat Area")
ggplot(data = veg_summary_tab, aes(x = reorder(group,per_chg), y = per_chg, fill = criteria))+
theme_few()+
scale_fill_brewer(palette = "Set1")+
geom_bar(stat = "identity")+
coord_flip()+
theme(legend.position = "right",
text=element_text(size=14,face = "bold",color = "black"),
axis.text.x = element_text(colour = "black",face="plain"),
axis.text.y = element_text(colour = "black",face="plain"))+
facet_wrap(vars(scene),dir = "v")+
xlab(element_blank())+
ylab("% Change in Habitat Area")
# load barplots of % change
plot.bars <- function(one_fish_metrics,title){
one_fish_metrics$chg_barplots
}
map2(post_fish_figs,species_list,plot.bars)
# plots of % change by for single species (all lifestages) faceted by scenario
ggplot(data = fish_pc_tab, aes(x = month, y = per_chg, fill = species,alpha = lifestage))+
theme_few()+
scale_fill_brewer(palette = "Set1")+
geom_bar(stat = "identity",position = "dodge")+
theme(legend.position = "bottom",
text=element_text(size=14,face = "bold",color = "black"),
axis.text.x = element_text(colour = "black",face="plain"),
axis.text.y = element_text(colour = "black",face="plain"))+
facet_wrap(vars(scene),dir = "v")+
scale_x_continuous(breaks=c(1,2,3,4,5,6,7,8,9,10,11,12),
labels = c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"))+
{if(length(lifestages)>1) scale_alpha_discrete(range = c(1,0.35))}+
{if(length(lifestages)==1) scale_alpha_discrete(guide="none",range = c(1,1))}+
ylab("% Change in Habitat Area")+
xlab("Month")
# Fish post-processing
all_fish_post_out <- list()
all_fish_post_out <- lapply(scene_names, function(scene_name){
s <- scene_list[[scene_name]]
post_fish_outputs <- list()
post_fish_outputs <- lapply(species_list, function(species){
output_name <- load(file=paste(reach_wd,"dss_outputs/","internal/",reach_run,"_",species,"_fish_outputs.rdata",sep="")) # load fish outputs
eval(parse(text=paste("one_spec=",output_name)))
for(i in 1:length(one_spec)){ # extracts the outputs by species into their own object
tempobj = one_spec[[i]]
eval(parse(text=paste(names(one_spec)[[i]],"=tempobj")))
}
# Flow-Scenario related scripts
source("interp.table.R")
inter_tab <- lapply(lifestages, function(a) interp.table(a,s,area_look_tab,NormalizeByL))
names(inter_tab) <- lifestages
post_fish_outputs$inter_tab <- inter_tab
# Generate and view plots of total area through the hydrograph
source("interp.plot.R")
inter_plots <- interp.plot(inter_tab,NormalizeByL,species,scene_name,reach_run)
names(inter_plots) <- species
post_fish_outputs$inter_plots <- inter_plots
## Generate Data Frames of moving X-Day area and discharge statistics
if(CalcXDayStats=="Yes"){
source("x.day.stats.R")
x_day_stats <- lapply(lifestages, function(a) x.day.stats(a,inter_tab,x_days,NormalizeByL,reach_length))
names(x_day_stats) <- lifestages
post_fish_outputs$x_day_stats <- x_day_stats
}
source("avg.month.area.R")
avg_monthly_area <- lapply(lifestages, function(a) avg.month.area(a,inter_tab,NormalizeByL))
names(avg_monthly_area) <- lifestages
post_fish_outputs$avg_monthly_area <- avg_monthly_area
# end of flow scenario dependent processes
# save outputs (dss_outputs) for use in scenario.comparison.R
list.save(post_fish_outputs,file=paste(reach_wd,"dss_outputs/","internal/",reach_run,"_",scene_name,"_post_",species,".rdata",sep=""))
return(post_fish_outputs)
}) # end of single species function
names(post_fish_outputs) <- species_list
return(post_fish_outputs)
}) # end of flow scenario list function
names(all_fish_post_out) <- names(scene_list)
# Figures and tables for fish
post_fish_figs <- list()
post_fish_figs <- lapply(species_list, function(species){
# Load all scenario results for species
scene_fish_out <- list()
scene_fish_out <- lapply(scene_names, function(scene_name){
output_name <- load(file=paste(reach_wd,"dss_outputs/","internal/",reach_run,"_",scene_name,"_post_",species,".rdata",sep="")) # load post-fish outputs
eval(parse(text=paste("hold_fish_output=",output_name)))
return(hold_fish_output)
})
names(scene_fish_out) <- scene_names
source("plot.10day.ts.R")
ten_day_ts_plt <- lapply(lifestages, function(a) plot.10day.ts(a,species,scene_fish_out,scene_list,NormalizeByL,post_tag))
names(ten_day_ts_plt) <- lifestages
post_fish_figs$ten_day_ts_plt <- ten_day_ts_plt
source("build.10day.tables.R")
ten_day_min_outputs <- lapply(lifestages, function(a) build.10day.tables(a,species,scene_list,scene_fish_out,post_tag))
names(ten_day_min_outputs) <- lifestages
post_fish_figs$ten_day_min_outputs <- ten_day_min_outputs
source("make.barplots.chg.R")
chg_barplots <- lapply(lifestages, function(a) make.barplots.chg(a,species,ten_day_min_outputs,post_tag))
names(chg_barplots) <- lifestages
post_fish_figs$chg_barplots <- chg_barplots
return(post_fish_figs)
})
names(post_fish_figs) <- species_list
# pull % change
fish_pc_builder <- lapply(species_list, function(species){
one_spec_list <- lapply(lifestages, function(a){ # pull % change tables for all lifestages from a single species
post_fish_figs[[species]]$ten_day_min_outputs[[a]]$sum_all_yrs_dif
})
names(one_spec_list) <- lifestages
one_spec_df <- bind_rows(one_spec_list,.id = "lifestage") # build single df per species
return(one_spec_df)
})
names(fish_pc_builder) <- species_list
# add criteria - nativeness
fish_pc_tab <- bind_rows(fish_pc_builder,.id = "species") %>%
filter(scene != "baseline_q") %>%
mutate(criteria = ifelse(species %in% native_list,"native","non-native"))
# load barplots of % change
plot.bars <- function(one_fish_metrics,title){
one_fish_metrics$chg_barplots
}
map2(post_fish_figs,species_list,plot.bars)
# plots of % change by for single species (all lifestages) faceted by scenario
ggplot(data = fish_pc_tab, aes(x = month, y = per_chg, fill = species,alpha = lifestage))+
theme_few()+
scale_fill_brewer(palette = "Set1")+
geom_bar(stat = "identity",position = "dodge")+
theme(legend.position = "bottom",
text=element_text(size=14,face = "bold",color = "black"),
axis.text.x = element_text(colour = "black",face="plain"),
axis.text.y = element_text(colour = "black",face="plain"))+
facet_wrap(vars(scene),dir = "v")+
scale_x_continuous(breaks=c(1,2,3,4,5,6,7,8,9,10,11,12),
labels = c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"))+
{if(length(lifestages)>1) scale_alpha_discrete(range = c(1,0.35))}+
{if(length(lifestages)==1) scale_alpha_discrete(guide="none",range = c(1,1))}+
ylab("% Change in Habitat Area")+
xlab("Month")
scene_veg_out$baseline_q$ep_map
ex_ep_map <- scene_veg_out$baseline_q$ep_map
ex_prob_map <- scene_veg_out$baseline_q$prob_veg_maps$tall_trees
plot(ex_ep_map)
?levelplot
plot(ex_ep_map,col="dodgerblue3")
plot(ex_ep_map,col="Set1")
# create plots of the habitat area-discharge curves
source("plot.a.q.curve.R"); source("plot.a.q.curve.in.chan.R")
area_look_plots <- lapply(lifestages, function(a) plot.a.q.curve(fish_outputs,species_list,a,NormalizeByL,fish_tag,reach_run))
# create plots of the habitat area-discharge curves
source("plot.a.q.curve.R"); source("plot.a.q.curve.in.chan.R")
area_look_plots <- lapply(lifestages, function(a) plot.a.q.curve(fish_outputs,species_list,a,NormalizeByL,fish_tag,reach_run))
# create plots of the habitat area-discharge curves
source("plot.a.q.curve.R"); source("plot.a.q.curve.in.chan.R")
area_look_plots <- lapply(lifestages, function(a) plot.a.q.curve(fish_outputs,species_list,a,NormalizeByL,fish_tag,reach_run))
source("plot.a.q.curve.R")
area_look_plots <- lapply(lifestages, function(a) plot.a.q.curve(fish_outputs,species_list,a,NormalizeByL,fish_tag,reach_run))
area_look_plots <- lapply(lifestages, function(a) plot.a.q.curve(fish_outputs,species_list,a,NormalizeByL,fish_tag,reach_run))
ggplot(all_a_tab)+
geom_line(aes(x=discharge,y=total_area,color=species),size=1)+
theme_gray()+
scale_fill_brewer(palette = "Set1")+
theme(text=element_text(size=14,face = "bold"),
panel.border = element_rect(fill = NA,size=1),
legend.justification = c("right","top"),
axis.text.x = element_text(colour = "black",face="plain"),
axis.text.y = element_text(colour = "black",face="plain"))+
labs(y=bquote('Total Habitat Area in '~m^2),x=bquote("Discharge in "~m^3/s))
source("plot.a.q.curve.R"); source("plot.a.q.curve.in.chan.R")
area_look_plots <- lapply(lifestages, function(a) plot.a.q.curve(fish_outputs,species_list,a,NormalizeByL,fish_tag,reach_run))
source("plot.a.q.curve.R"); source("plot.a.q.curve.in.chan.R")
area_look_plots <- lapply(lifestages, function(a) plot.a.q.curve(fish_outputs,species_list,a,NormalizeByL,fish_tag,reach_run))
?scale_fill_brewer
source("plot.a.q.curve.R"); source("plot.a.q.curve.in.chan.R")
area_look_plots <- lapply(lifestages, function(a) plot.a.q.curve(fish_outputs,species_list,a,NormalizeByL,fish_tag,reach_run))
# This script will house the pre-processing options and functionality
# This script will process 2D hydraulic modeling results
# This script will rasterize substrate maps if applicable
# Last edited by Elaina Passero on 02/18/20
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis",
"ggplot2","data.table","dplyr","plotly","spex","stars","igraph","deldir","hydroTSM","rlist")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
# load the installed libraries in the packages list
lapply(packages,library,character.only=TRUE)
## Primary Inputs
wd <- "C:/Users/epassero/Desktop/VRDSS/verde-refdss/" # Project working directory
#wd <- "/Users/Morrison/Documents/Active Research Projects/Verde REFDSS/verde-refdss/" # Set path to local repository
setwd(wd)
hab_mets <- list("Depth") #,"Velocity","WaterSurfaceElevation") #Variables from iRIC calculation result used for habitat analysis - case sensitive!
reach_name <- "USBeasley1" # Reach of interest
model_run <- "2.12.20" # Should match end of name of folder with results
dis_unit <- "cms" #units of discharge
# Yes- external rasters or No- rasterize iRIC results. Inputs required if No.
LoadExternal <- "No"; if(LoadExternal=="No"){
skip_num <- 0 # number of rows to skip when reading in raw outputs
x_loc <- "X" # field name of X coordinate in model outputs - case sensitive
y_loc <- "Y" # field name of y coordinate in model outputs - case sensitive
dem <- "BeasleyUS_0.25m_20191108.tif" # Name of dem: VerdeBeasley1Elev.tif, smrf_dem_v241.tif, braidallpts_dem.tif, GilaMGnd.tif
# Does the resolution of the rasters need to be manually set? If No, dem resolution will be used.
setRes <- "Yes"; if(setRes=="Yes"){
res <- c(0.5,0.5)} # resolution of rasters if they need to be manually set
}
## Options - If set to No, inputs are not required for option
# Yes or No. Choose whether or not to check substrate conditions as part of suitable habitat
CheckSub <- "Yes"; if(CheckSub=="Yes"){
sub_name <- "BeasleyUS_SedThiessenPoly1Dissolved" # shapefile name with no extension BeasleyUS_SedThiessenPoly1Dissolved
sub_field <- "ParticalSi"} # name of field in substrate map containing substrate type info; ParticalSi or substrate
### End of User Inputs ###
### Begin Processing ###
reach_run <- paste(reach_name,"_",model_run,sep="")
reach_wd <- paste(wd,"reaches","/",reach_run,"/",sep = "")
rasterOptions(overwrite = TRUE,tmpdir = paste(reach_wd,"temp/",sep=""))
pre_outputs <- list()
if(LoadExternal == "No"){
## Format result CSVs and get list of discharges
source("get.results.R")
temp_list <- get.results(reach_wd,skip_num,dis_unit)
delim_list <- temp_list$delim_list
modeled_q <- temp_list$modeled_q
rm(temp_list)
## Convert iRIC outputs to rasterBricks by variable
source("iric.process.smr.R")
out_val_rast <- list()
out_val_rast <- lapply(hab_mets, function(m) iric.process.smr(m,delim_list,reach_wd,dem,x_loc,y_loc,setRes,res))
names(out_val_rast) <-hab_mets
rm(delim_list)
} else{
## Load in external rasterBricks and discharges
source("load.cherry.R")
out_val_rast <- load.cherry(reach_wd,Check0Flow)
names(out_val_rast)<-c(hab_mets,"modeled_q")
modeled_q <- out_val_rast$modeled_q
out_val_rast[length(out_val_rast)]<-NULL
}
pre_outputs$out_val_rast <- out_val_rast
pre_outputs$modeled_q <- modeled_q
## Load substrate
if(CheckSub == "Yes"){
base_rast <- out_val_rast[[1]][[1]] # will be overwritten during rasterization - provides setup
sub_map <- readOGR(dsn=paste(wd,"reaches", "/", reach_name, sep=""),layer=sub_name) # read in substrate shapefile
rast_sub_map <- rasterize(sub_map,base_rast,field=sub_map@data[[sub_field]],update=TRUE)
pre_outputs$rast_sub_map <- rast_sub_map
}
# save outputs for internal use
list.save(pre_outputs,file=paste(reach_wd,"dss_outputs/","internal/",reach_run,"_pre_outputs.rdata",sep=""))
reach_run <- paste(reach_name,"_",model_run,sep="")
reach_wd <- paste(wd,"reaches","/",reach_run,"/",sep = "")
# create list of flow scenario data frames
scene_list <- lapply(scene_names, function(s){
q_ts <- na.omit(fread(file=paste(reach_wd,"flow_scenarios","/",reach_name,"_",s,".csv",sep=""),
header=TRUE, sep = ",",data.table=FALSE)) %>%
mutate(date_form = as.Date(date)) %>%
select(-date) %>%
rename(date = date_form)
if(DateRange=="Yes"){
q_ts <- subset(q_ts, date > as.Date(start_date))
q_ts <- subset(q_ts, date < as.Date(end_date))
}
return(q_ts)
})
names(scene_list) <- scene_names
# Load pre.processing outputs
output_name <- load(file=paste(reach_wd,"dss_outputs/","internal/",reach_run,"_pre_outputs.rdata",sep="")) # load rasterized 2D modeling results
eval(parse(text=paste("pre_outputs=",output_name)))
out_val_rast <- pre_outputs$out_val_rast
modeled_q <- pre_outputs$modeled_q
# Flow scenarios to calculate metrics for
scene_names <- c("baseline_q","red_25_percent","red_all_q_10")
veg_list <- c("drgt_tol_shrubs","tall_trees","popufre","prosvel","saligoo") # vegetation group list
reach_name <- "USBeasley1" # Should match name of folder with results
model_run <- "2.12.20" # Should match end of name of folder with results
dis_unit <- "cms" #units of discharge
# Riparian vegetation post-processing
all_veg_post_out <- list()
all_veg_post_out <- lapply(scene_names, function(scene_name){
s <- scene_list[[scene_name]]
source("q.ep.weibull.R")
hydro_ep <- q.ep.weibull(s,modeled_q,scene_name)
all_veg_post_out$hydro_ep <- hydro_ep
source("make.inun.q.map.R")
wet_map <- make.inun.q.map(hydro_ep,out_val_rast,modeled_q,scene_name,reach_run)
all_veg_post_out$wet_map <- wet_map
source("make.ep.maps.R")
ep_map <- make.ep.maps(hydro_ep,out_val_rast,modeled_q,scene_name)
all_veg_post_out$ep_map <- ep_map
# make maps of probability of occurrence of vegetation
all_veg_logit <- fread(paste(reach_wd,"habitat_info","/",reach_name,"_veg_pref",".csv",sep=""),
header=TRUE, sep = ",",data.table = FALSE) # load logistic equations
source("find.veg.logit.R"); source("find.prob.occur.R"); source("make.veg.maps.R")
prob_veg_maps <- lapply(veg_list, function(v) {
one_veg_logit <- find.veg.logit(all_veg_logit,v)
hydro_ep_prob <- find.prob.occur(v,hydro_ep,one_veg_logit) # outputs table of discharge, EP of discharge, and Prob of Veg for discharge
prob_veg_map <- make.veg.maps(v,ep_map,hydro_ep_prob,scene_name)
save(prob_veg_map, file=paste(reach_wd,"dss_outputs/","internal/",reach_run,"_",scene_name,"_post_",v,".RData",sep=""))
return(prob_veg_map)
})
names(prob_veg_maps) <- veg_list
all_veg_post_out$prob_veg_maps <- prob_veg_maps
return(all_veg_post_out)
}) # end of flow scenario list function
names(all_veg_post_out) <- names(scene_list)
# create list of flow scenario data frames
scene_list <- lapply(scene_names, function(s){
q_ts <- na.omit(fread(file=paste(reach_wd,"flow_scenarios","/",reach_name,"_",s,".csv",sep=""),
header=TRUE, sep = ",",data.table=FALSE)) %>%
mutate(date_form = as.Date(date)) %>%
select(-date) %>%
rename(date = date_form)
if(DateRange=="Yes"){
q_ts <- subset(q_ts, date > as.Date(start_date))
q_ts <- subset(q_ts, date < as.Date(end_date))
}
return(q_ts)
})
names(scene_list) <- scene_names
# Flow scenarios to calculate metrics for
scene_names <- c("baseline_q","red_25_percent","red_all_q_10")
reach_run <- paste(reach_name,"_",model_run,sep="")
reach_wd <- paste(wd,"reaches","/",reach_run,"/",sep = "")
# create list of flow scenario data frames
scene_list <- lapply(scene_names, function(s){
q_ts <- na.omit(fread(file=paste(reach_wd,"flow_scenarios","/",reach_name,"_",s,".csv",sep=""),
header=TRUE, sep = ",",data.table=FALSE)) %>%
mutate(date_form = as.Date(date)) %>%
select(-date) %>%
rename(date = date_form)
if(DateRange=="Yes"){
q_ts <- subset(q_ts, date > as.Date(start_date))
q_ts <- subset(q_ts, date < as.Date(end_date))
}
return(q_ts)
})
names(scene_list) <- scene_names
# Load pre.processing outputs
output_name <- load(file=paste(reach_wd,"dss_outputs/","internal/",reach_run,"_pre_outputs.rdata",sep="")) # load rasterized 2D modeling results
eval(parse(text=paste("pre_outputs=",output_name)))
out_val_rast <- pre_outputs$out_val_rast
modeled_q <- pre_outputs$modeled_q
# Yes or No. Indicate whether or not to substrate was a condition of suitable habitat
CheckSub <- "Yes"
# Yes or No. Choose whether or not to normalize habitat area by reach length
NormalizeByL <- "Yes"; if(NormalizeByL=="Yes"){
reach_length <- 0.5
length_unit <- "km"}
# Yes or No. Choose whether or not to calculate X-day statistics. Must supply number of days.
CalcXDayStats <- "No"; if(CalcXDayStats=="Yes"){
x_days <- 7} # number of days for moving area statistics
# Yes or No. Yes - limit analysis to supplied dates. No - consider entire hydrograph.
DateRange <- "No"; if(DateRange=="Yes"){
start_date <- "1974-01-01" # "YYYY-MM-DD"
end_date <- "1994-12-31"} # "YYYY-MM-DD"
# Flow scenarios to calculate metrics for
scene_names <- c("baseline_q","red_25_percent","red_all_q_10")
### End of User Inputs ###
### Begin post-processing ###
reach_run <- paste(reach_name,"_",model_run,sep="")
reach_wd <- paste(wd,"reaches","/",reach_run,"/",sep = "")
# create list of flow scenario data frames
scene_list <- lapply(scene_names, function(s){
q_ts <- na.omit(fread(file=paste(reach_wd,"flow_scenarios","/",reach_name,"_",s,".csv",sep=""),
header=TRUE, sep = ",",data.table=FALSE)) %>%
mutate(date_form = as.Date(date)) %>%
select(-date) %>%
rename(date = date_form)
if(DateRange=="Yes"){
q_ts <- subset(q_ts, date > as.Date(start_date))
q_ts <- subset(q_ts, date < as.Date(end_date))
}
return(q_ts)
})
names(scene_list) <- scene_names
# Load pre.processing outputs
output_name <- load(file=paste(reach_wd,"dss_outputs/","internal/",reach_run,"_pre_outputs.rdata",sep="")) # load rasterized 2D modeling results
eval(parse(text=paste("pre_outputs=",output_name)))
out_val_rast <- pre_outputs$out_val_rast
modeled_q <- pre_outputs$modeled_q
# Riparian vegetation post-processing
all_veg_post_out <- list()
all_veg_post_out <- lapply(scene_names, function(scene_name){
s <- scene_list[[scene_name]]
source("q.ep.weibull.R")
hydro_ep <- q.ep.weibull(s,modeled_q,scene_name)
all_veg_post_out$hydro_ep <- hydro_ep
source("make.inun.q.map.R")
wet_map <- make.inun.q.map(hydro_ep,out_val_rast,modeled_q,scene_name,reach_run)
all_veg_post_out$wet_map <- wet_map
source("make.ep.maps.R")
ep_map <- make.ep.maps(hydro_ep,out_val_rast,modeled_q,scene_name)
all_veg_post_out$ep_map <- ep_map
# make maps of probability of occurrence of vegetation
all_veg_logit <- fread(paste(reach_wd,"habitat_info","/",reach_name,"_veg_pref",".csv",sep=""),
header=TRUE, sep = ",",data.table = FALSE) # load logistic equations
source("find.veg.logit.R"); source("find.prob.occur.R"); source("make.veg.maps.R")
prob_veg_maps <- lapply(veg_list, function(v) {
one_veg_logit <- find.veg.logit(all_veg_logit,v)
hydro_ep_prob <- find.prob.occur(v,hydro_ep,one_veg_logit) # outputs table of discharge, EP of discharge, and Prob of Veg for discharge
prob_veg_map <- make.veg.maps(v,ep_map,hydro_ep_prob,scene_name)
save(prob_veg_map, file=paste(reach_wd,"dss_outputs/","internal/",reach_run,"_",scene_name,"_post_",v,".RData",sep=""))
return(prob_veg_map)
})
names(prob_veg_maps) <- veg_list
all_veg_post_out$prob_veg_maps <- prob_veg_maps
return(all_veg_post_out)
}) # end of flow scenario list function
scene_names <- c("baseline_q")
#veg_list <- c("drgt_tol_shrubs","tall_trees","popufre","prosvel","saligoo") # vegetation group list
veg_list <- c("drgt_tol_shrubs") # vegetation group list
hab_mets <- list("Depth") #Variables from iRIC calculation result used for habitat analysis - case sensitive
# Riparian vegetation post-processing
all_veg_post_out <- list()
all_veg_post_out <- lapply(scene_names, function(scene_name){
s <- scene_list[[scene_name]]
source("q.ep.weibull.R")
hydro_ep <- q.ep.weibull(s,modeled_q,scene_name)
all_veg_post_out$hydro_ep <- hydro_ep
source("make.inun.q.map.R")
wet_map <- make.inun.q.map(hydro_ep,out_val_rast,modeled_q,scene_name,reach_run)
all_veg_post_out$wet_map <- wet_map
source("make.ep.maps.R")
ep_map <- make.ep.maps(hydro_ep,out_val_rast,modeled_q,scene_name)
all_veg_post_out$ep_map <- ep_map
# make maps of probability of occurrence of vegetation
all_veg_logit <- fread(paste(reach_wd,"habitat_info","/",reach_name,"_veg_pref",".csv",sep=""),
header=TRUE, sep = ",",data.table = FALSE) # load logistic equations
source("find.veg.logit.R"); source("find.prob.occur.R"); source("make.veg.maps.R")
prob_veg_maps <- lapply(veg_list, function(v) {
one_veg_logit <- find.veg.logit(all_veg_logit,v)
hydro_ep_prob <- find.prob.occur(v,hydro_ep,one_veg_logit) # outputs table of discharge, EP of discharge, and Prob of Veg for discharge
prob_veg_map <- make.veg.maps(v,ep_map,hydro_ep_prob,scene_name)
save(prob_veg_map, file=paste(reach_wd,"dss_outputs/","internal/",reach_run,"_",scene_name,"_post_",v,".RData",sep=""))
return(prob_veg_map)
})
names(prob_veg_maps) <- veg_list
all_veg_post_out$prob_veg_maps <- prob_veg_maps
return(all_veg_post_out)
}) # end of flow scenario list function
names(all_veg_post_out) <- names(scene_list)
# create list of flow scenario data frames
scene_list <- lapply(scene_names, function(s){
q_ts <- na.omit(fread(file=paste(reach_wd,"flow_scenarios","/",reach_name,"_",s,".csv",sep=""),
header=TRUE, sep = ",",data.table=FALSE)) %>%
mutate(date_form = as.Date(date)) %>%
select(-date) %>%
rename(date = date_form)
if(DateRange=="Yes"){
q_ts <- subset(q_ts, date > as.Date(start_date))
q_ts <- subset(q_ts, date < as.Date(end_date))
}
return(q_ts)
})
names(scene_list) <- scene_names
# Riparian vegetation post-processing
all_veg_post_out <- list()
all_veg_post_out <- lapply(scene_names, function(scene_name){
s <- scene_list[[scene_name]]
source("q.ep.weibull.R")
hydro_ep <- q.ep.weibull(s,modeled_q,scene_name)
all_veg_post_out$hydro_ep <- hydro_ep
source("make.inun.q.map.R")
wet_map <- make.inun.q.map(hydro_ep,out_val_rast,modeled_q,scene_name,reach_run)
all_veg_post_out$wet_map <- wet_map
source("make.ep.maps.R")
ep_map <- make.ep.maps(hydro_ep,out_val_rast,modeled_q,scene_name)
all_veg_post_out$ep_map <- ep_map
# make maps of probability of occurrence of vegetation
all_veg_logit <- fread(paste(reach_wd,"habitat_info","/",reach_name,"_veg_pref",".csv",sep=""),
header=TRUE, sep = ",",data.table = FALSE) # load logistic equations
source("find.veg.logit.R"); source("find.prob.occur.R"); source("make.veg.maps.R")
prob_veg_maps <- lapply(veg_list, function(v) {
one_veg_logit <- find.veg.logit(all_veg_logit,v)
hydro_ep_prob <- find.prob.occur(v,hydro_ep,one_veg_logit) # outputs table of discharge, EP of discharge, and Prob of Veg for discharge
prob_veg_map <- make.veg.maps(v,ep_map,hydro_ep_prob,scene_name)
save(prob_veg_map, file=paste(reach_wd,"dss_outputs/","internal/",reach_run,"_",scene_name,"_post_",v,".RData",sep=""))
return(prob_veg_map)
})
names(prob_veg_maps) <- veg_list
all_veg_post_out$prob_veg_maps <- prob_veg_maps
return(all_veg_post_out)
}) # end of flow scenario list function
names(all_veg_post_out) <- names(scene_list)
plot(all_veg_post_out$baseline_q$ep_map)
