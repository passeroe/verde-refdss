}
View(altered_hydro)
red_above_med_25 <- data.frame()
for(m in 1:12){
med_q <- as.numeric(med_months[m,2])
hydro <- filter(hydrograph,month(date)==m) %>%
dplyr::mutate(red_q = ifelse(discharge > med_q,discharge*0.75,discharge))
red_above_med_25 <- dplyr::bind_rows(red_above_med_25,hydro)
}
red_above_med_25 <- select(red_above_med_25,-discharge) %>%
dplyr::rename(discharge = red_q)
write.csv(red_above_med_25,file="red_above_med_25_ts.csv")
# Yes or No. Yes - limit analysis to supplied dates. No - consider entire hydrograph.
DateRange <- "No"; if(DateRange=="Yes"){
start_date <- "2008-01-01" # "YYYY-MM-DD"
end_date <- "2018-12-31"} # "YYYY-MM-DD"
# Calculate exceedence probability for flows in scenario
flow_scene_ep <- data.frame(discharge = hydrograph["discharge"],q_rank=rank(-hydrograph["discharge"],ties.method = "min")) # ranks discharges; same values get same ranks
n <- as.numeric(length(flow_scene_ep$discharge))
flow_scene_ep$EP <- flow_scene_ep$q_rank/(1+n)
df_m_q <- data.frame(discharge=modeled_q) %>%
filter(discharge < max(hydrograph$discharge)) # modeled discharges within range of flow scenario
View(flow_scene_ep)
hydro_ep <- bind_rows(flow_scene_ep,data.frame(anti_join(df_m_q["discharge"],flow_scene_ep["discharge"]))) %>%
arrange(discharge)
View(hydro_ep)
hydrograph <- na.omit(fread(paste(reach_wd,"flow_scenarios","/",reach_name,"_hydrograph",".csv",sep=""),
header=TRUE, sep = ",",data.table=FALSE))
hydrograph$date <- as.Date(hydrograph$date, format="%m/%d/%Y")
if(DateRange=="Yes"){
hydrograph <- subset(hydrograph, date > as.Date(start_date))
hydrograph <- subset(hydrograph, date < as.Date(end_date))
}
# to convert from CFS to CMS
hydrograph <- hydrograph %>%
mutate(discharge.cms = discharge*0.02832) %>%
select(-discharge) %>%
rename(discharge = discharge.cms)
# Yes or No. Choose whether to save flow scenario
SaveScene <- "Yes"
if(SaveScene == "Yes"){
scene_name <- "red_all_q_10"
}
hydroperiods <- c("03-19","06-01","09-01","12-01") # the start dates (mm-dd) of each hydroperiod
hp_names <- c("spring","summer","fall","winter")
## Add inputs in the following order: hydroperiod name, enforce median (y/n),
# median discharge for season (put NA if not enforcing median),
# fixed change (withdrawal or return flow), percent change in flow as a decimal (+/-)
inputs_hp <- list(
spring <- list("spring","No",NA,0,-.1),
summer <- list("summer","No",NA,0,-.1),
fall <- list("fall","No",NA,0,-.1),
winter <- list("winter","No",NA,0,-.1)
)
# add hydroperiods to hydrograph
source("add_hydroperiods.R")
hydrograph_hp <- add_hydroperiods(hydroperiods,hp_names,hydrograph)
# applies alterations to historic flow record
source("alter.hydrograph.R")
scene_by_hp <- lapply(inputs_hp, function(h){
hp <- h[[1]]
EnforceMed <- h[[2]]
median_q <- h[[3]]
fixed_chg <- h[[4]]
per_chg <- h[[5]]
alter.hydrograph(hydrograph_hp,EnforceMed,median_q,fixed_chg,per_chg,hp)
})
names(scene_by_hp) <- hp_names
# create df of flow scenario
flow_scene <- bind_rows(scene_by_hp) %>%
arrange(date)
View(flow_scene)
flow_scene <- bind_rows(scene_by_hp) %>%
arrange(date) %>%
select(-hydroperiod)
# Save scenario info
if(SaveScene == "Yes"){
scene_info <- list(hydroperiods,hp_names,inputs_hp)
list.save(scene_info,file=paste(reach_wd,"flow_scenarios","/",scene_name,"_inputs",".rdata",sep="")) # inputs
write.csv(flow_scene,file=paste(reach_wd,"flow_scenarios","/",reach_name,"_",scene_name,".csv",sep=""),row.names = FALSE) # output
}
hydrograph <- na.omit(fread(paste(reach_wd,"flow_scenarios","/",reach_name,"_hydrograph",".csv",sep=""),
header=TRUE, sep = ",",data.table=FALSE))
hydrograph$date <- as.Date(hydrograph$date, format="%m/%d/%Y")
if(DateRange=="Yes"){
hydrograph <- subset(hydrograph, date > as.Date(start_date))
hydrograph <- subset(hydrograph, date < as.Date(end_date))
}
# to convert from CFS to CMS
hydrograph <- hydrograph %>%
mutate(discharge.cms = discharge*0.02832) %>%
select(-discharge) %>%
rename(discharge = discharge.cms)
write.csv(hydrograph,file="hold.csv")
write.csv(modeled_q,file="modeled_q_list.csv")
?plot
?cellStats
View(ten_day_min_outputs)
# This script will house the post-processing options and functionality
# Last edited by Elaina Passero on 12/05/19
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis",
"ggplot2","data.table","dplyr","spex","stars","igraph","deldir","hydroTSM",
"lubridate","rlist")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
# load the installed libraries in the packages list
lapply(packages,library,character.only=TRUE)
###########################################
# User inputs
wd <- "C:/Users/epassero/Desktop/VRDSS/verde-refdss/" # Project working directory
#wd <- "/Users/Morrison/Documents/Active Research Projects/Verde REFDSS/verde-refdss/" # Set path to local repository
setwd(wd)
hab_mets <- list("Depth","Velocity") #Variables from iRIC calculation result used for habitat analysis - case sensitive
#species_list <- c("longfindace","desertsucker") #"sonoransucker") #"yellowbullhead", "sonoransucker","redshiner","roundtailchub","greensunfish","fatheadminnow","speckleddace")
species_list <- c("desertsucker","smallmouthbass") # species list for chris
veg_list <- c("drgt_tol_shrubs","tall_trees","popufre","prosvel")
lifestages <- list("adult") #lifestages from oldest to youngest; must match order in HSC table
reach_name <- "USBeasley1" # Should match name of folder with results
dis_unit <- "cms" #units of discharge
# Yes or No. Indicate whether or not to substrate was a condition of suitable habitat
CheckSub <- "Yes"
# Yes or No. Choose whether or not to normalize habitat area by reach length
NormalizeByL <- "Yes"; if(NormalizeByL=="Yes"){
reach_length <- 0.5
length_unit <- "km"}
# Yes or No. Choose whether or not to calculate X-day statistics. Must supply number of days.
CalcXDayStats <- "No"; if(CalcXDayStats=="Yes"){
x_days <- 10} # number of days for moving discharge and area statistics
# Yes or No. Yes - limit analysis to supplied dates. No - consider entire hydrograph.
DateRange <- "No"; if(DateRange=="Yes"){
start_date <- "1974-01-01" # "YYYY-MM-DD"
end_date <- "1994-12-31"} # "YYYY-MM-DD"
# Yes or No. Yes - bring in flow scenarios for
LoadScenario <- "No"; if(LoadScenario == "Yes"){
scene_names <- c("baseline")
}
CompareScenes <- "No"
# Begin post-processing #
reach_wd <- paste(wd,"reaches","/",reach_name,"/",sep = "")
output_name <- load(file=paste(reach_wd,reach_name,"_fish_outputs.rdata",sep="")) # load fish outputs
eval(parse(text=paste("fish_outputs=",output_name)))
## Read in hydrograph if one is supplied
hydrograph <- na.omit(fread(paste(reach_wd,"flow_scenarios","/",reach_name,"_hydrograph",".csv",sep=""),
header=TRUE, sep = ",",data.table=FALSE))
hydrograph$date <- as.Date(hydrograph$date, format="%m/%d/%Y")
if(DateRange=="Yes"){
hydrograph <- subset(hydrograph, date > as.Date(start_date))
hydrograph <- subset(hydrograph, date < as.Date(end_date))
}
# to convert from CFS to CMS
hydrograph <- hydrograph %>%
mutate(discharge.cms = discharge*0.02832) %>%
select(-discharge) %>%
rename(discharge = discharge.cms)
# create list of flow scenario data frames
if(LoadScenario == "Yes"){
scene_list <- lapply(scene_names, function(s){
q_ts <- na.omit(fread(file=paste(reach_wd,"flow_scenarios","/",reach_name,"_",s,".csv",sep=""),
header=TRUE, sep = ",",data.table=FALSE)) %>%
mutate(date_form = as.Date(date)) %>%
select(-date) %>%
rename(date = date_form)
if(DateRange=="Yes"){
q_ts <- subset(q_ts, date > as.Date(start_date))
q_ts <- subset(q_ts, date < as.Date(end_date))
}
return(q_ts)
})
names(scene_list) <- scene_names
#scene_list$hydrograph <- hydrograph
scene_names <- names(scene_list) # updated scene name list for labeling
} else{
scene_list <- list(hydrograph)
}
# Riparian vegetation post-processing
output_name <- load(file=paste(reach_wd,reach_name,"_pre_outputs.rdata",sep="")) # load rasterized 2D modeling results
eval(parse(text=paste("pre_outputs=",output_name)))
out_val_rast <- pre_outputs$out_val_rast
modeled_q <- pre_outputs$modeled_q
scene_veg_out <- list()
scene_veg_out <- lapply(scene_names, function(scene_name){
s <- scene_list[[scene_name]]
source("q.ep.weibull.R")
hydro_ep <- q.ep.weibull(s,modeled_q,scene_name)
scene_veg_out$hydro_ep <- hydro_ep
# source("make.inun.q.map.R")
# wet_map <- make.inun.q.map(hydro_ep,out_val_rast,modeled_q,scene_name)
# scene_veg_out$wet_map <- wet_map
source("make.ep.maps.R")
ep_map <- make.ep.maps(hydro_ep,out_val_rast,modeled_q,scene_name)
scene_veg_out$ep_map <- ep_map
# make maps of probability of occurrence of vegetation
all_veg_logit <- fread(paste(reach_wd,"habitat_info","/",reach_name,"_veg_pref",".csv",sep=""),
header=TRUE, sep = ",",data.table = FALSE) # load logistic equations
source("find.veg.logit.R"); source("find.prob.occur.R"); source("make.veg.maps.R")
prob_veg_maps <- lapply(veg_list, function(v) {
one_veg_logit <- find.veg.logit(all_veg_logit,v)
hydro_ep_prob <- find.prob.occur(v,hydro_ep,one_veg_logit) # outputs table of discharge, EP of discharge, and Prob of Veg for discharge
prob_veg_maps <- make.veg.maps(v,ep_map,hydro_ep_prob,scene_name)
return(prob_veg_maps)
})
names(prob_veg_maps) <- veg_list
scene_veg_out$prob_veg_maps <- prob_veg_maps
return(scene_veg_out)
}) # end of flow scenario list function
names(scene_veg_out) <- names(scene_list)
scene_names <- c("baseline")
# Riparian vegetation post-processing
output_name <- load(file=paste(reach_wd,reach_name,"_pre_outputs.rdata",sep="")) # load rasterized 2D modeling results
eval(parse(text=paste("pre_outputs=",output_name)))
out_val_rast <- pre_outputs$out_val_rast
modeled_q <- pre_outputs$modeled_q
scene_veg_out <- list()
scene_veg_out <- lapply(scene_names, function(scene_name){
s <- scene_list[[scene_name]]
source("q.ep.weibull.R")
hydro_ep <- q.ep.weibull(s,modeled_q,scene_name)
scene_veg_out$hydro_ep <- hydro_ep
# source("make.inun.q.map.R")
# wet_map <- make.inun.q.map(hydro_ep,out_val_rast,modeled_q,scene_name)
# scene_veg_out$wet_map <- wet_map
source("make.ep.maps.R")
ep_map <- make.ep.maps(hydro_ep,out_val_rast,modeled_q,scene_name)
scene_veg_out$ep_map <- ep_map
# make maps of probability of occurrence of vegetation
all_veg_logit <- fread(paste(reach_wd,"habitat_info","/",reach_name,"_veg_pref",".csv",sep=""),
header=TRUE, sep = ",",data.table = FALSE) # load logistic equations
source("find.veg.logit.R"); source("find.prob.occur.R"); source("make.veg.maps.R")
prob_veg_maps <- lapply(veg_list, function(v) {
one_veg_logit <- find.veg.logit(all_veg_logit,v)
hydro_ep_prob <- find.prob.occur(v,hydro_ep,one_veg_logit) # outputs table of discharge, EP of discharge, and Prob of Veg for discharge
prob_veg_maps <- make.veg.maps(v,ep_map,hydro_ep_prob,scene_name)
return(prob_veg_maps)
})
names(prob_veg_maps) <- veg_list
scene_veg_out$prob_veg_maps <- prob_veg_maps
return(scene_veg_out)
}) # end of flow scenario list function
names(scene_veg_out) <- names(scene_list)
View(hydrograph)
hydrograph["discharge"]
-hydrograph["discharge"]
## Read in hydrograph if one is supplied
hydrograph <- na.omit(fread(paste(reach_wd,"flow_scenarios","/",reach_name,"_hydrograph",".csv",sep=""),
header=TRUE, sep = ",",data.table=FALSE))
hydrograph$date <- as.Date(hydrograph$date, format="%m/%d/%Y")
if(DateRange=="Yes"){
hydrograph <- subset(hydrograph, date > as.Date(start_date))
hydrograph <- subset(hydrograph, date < as.Date(end_date))
}
# to convert from CFS to CMS
hydrograph <- hydrograph %>%
mutate(discharge.cms = discharge*0.02832) %>%
select(-discharge) %>%
rename(discharge = discharge.cms)
# Riparian vegetation post-processing
output_name <- load(file=paste(reach_wd,reach_name,"_pre_outputs.rdata",sep="")) # load rasterized 2D modeling results
eval(parse(text=paste("pre_outputs=",output_name)))
out_val_rast <- pre_outputs$out_val_rast
modeled_q <- pre_outputs$modeled_q
scene_veg_out <- list()
scene_veg_out <- lapply(scene_names, function(scene_name){
s <- scene_list[[scene_name]]
source("q.ep.weibull.R")
hydro_ep <- q.ep.weibull(s,modeled_q,scene_name)
scene_veg_out$hydro_ep <- hydro_ep
# source("make.inun.q.map.R")
# wet_map <- make.inun.q.map(hydro_ep,out_val_rast,modeled_q,scene_name)
# scene_veg_out$wet_map <- wet_map
source("make.ep.maps.R")
ep_map <- make.ep.maps(hydro_ep,out_val_rast,modeled_q,scene_name)
scene_veg_out$ep_map <- ep_map
# make maps of probability of occurrence of vegetation
all_veg_logit <- fread(paste(reach_wd,"habitat_info","/",reach_name,"_veg_pref",".csv",sep=""),
header=TRUE, sep = ",",data.table = FALSE) # load logistic equations
source("find.veg.logit.R"); source("find.prob.occur.R"); source("make.veg.maps.R")
prob_veg_maps <- lapply(veg_list, function(v) {
one_veg_logit <- find.veg.logit(all_veg_logit,v)
hydro_ep_prob <- find.prob.occur(v,hydro_ep,one_veg_logit) # outputs table of discharge, EP of discharge, and Prob of Veg for discharge
prob_veg_maps <- make.veg.maps(v,ep_map,hydro_ep_prob,scene_name)
return(prob_veg_maps)
})
names(prob_veg_maps) <- veg_list
scene_veg_out$prob_veg_maps <- prob_veg_maps
return(scene_veg_out)
}) # end of flow scenario list function
names(scene_veg_out) <- names(scene_list)
# create list of flow scenario data frames
if(LoadScenario == "Yes"){
scene_list <- lapply(scene_names, function(s){
q_ts <- na.omit(fread(file=paste(reach_wd,"flow_scenarios","/",reach_name,"_",s,".csv",sep=""),
header=TRUE, sep = ",",data.table=FALSE)) %>%
mutate(date_form = as.Date(date)) %>%
select(-date) %>%
rename(date = date_form)
if(DateRange=="Yes"){
q_ts <- subset(q_ts, date > as.Date(start_date))
q_ts <- subset(q_ts, date < as.Date(end_date))
}
return(q_ts)
})
names(scene_list) <- scene_names
#scene_list$hydrograph <- hydrograph
scene_names <- names(scene_list) # updated scene name list for labeling
} else{
scene_list <- list("hydrograph")
}
# Riparian vegetation post-processing
output_name <- load(file=paste(reach_wd,reach_name,"_pre_outputs.rdata",sep="")) # load rasterized 2D modeling results
eval(parse(text=paste("pre_outputs=",output_name)))
out_val_rast <- pre_outputs$out_val_rast
modeled_q <- pre_outputs$modeled_q
scene_veg_out <- list()
scene_veg_out <- lapply(scene_names, function(scene_name){
s <- scene_list[[scene_name]]
source("q.ep.weibull.R")
hydro_ep <- q.ep.weibull(s,modeled_q,scene_name)
scene_veg_out$hydro_ep <- hydro_ep
# source("make.inun.q.map.R")
# wet_map <- make.inun.q.map(hydro_ep,out_val_rast,modeled_q,scene_name)
# scene_veg_out$wet_map <- wet_map
source("make.ep.maps.R")
ep_map <- make.ep.maps(hydro_ep,out_val_rast,modeled_q,scene_name)
scene_veg_out$ep_map <- ep_map
# make maps of probability of occurrence of vegetation
all_veg_logit <- fread(paste(reach_wd,"habitat_info","/",reach_name,"_veg_pref",".csv",sep=""),
header=TRUE, sep = ",",data.table = FALSE) # load logistic equations
source("find.veg.logit.R"); source("find.prob.occur.R"); source("make.veg.maps.R")
prob_veg_maps <- lapply(veg_list, function(v) {
one_veg_logit <- find.veg.logit(all_veg_logit,v)
hydro_ep_prob <- find.prob.occur(v,hydro_ep,one_veg_logit) # outputs table of discharge, EP of discharge, and Prob of Veg for discharge
prob_veg_maps <- make.veg.maps(v,ep_map,hydro_ep_prob,scene_name)
return(prob_veg_maps)
})
names(prob_veg_maps) <- veg_list
scene_veg_out$prob_veg_maps <- prob_veg_maps
return(scene_veg_out)
}) # end of flow scenario list function
names(scene_veg_out) <- names(scene_list)
# Calculate exceedence probability for flows in scenario
flow_scene_ep <- data.frame(discharge = hydrograph["discharge"],q_rank=rank(-hydrograph["discharge"],ties.method = "min")) # ranks discharges; same values get same ranks
n <- as.numeric(length(flow_scene_ep$discharge))
flow_scene_ep$EP <- flow_scene_ep$q_rank/(1+n)
rm(flow_scene_ep)
rm(n)
scene_names
scene_names <- "hydrograph"
scene_veg_out <- list()
scene_veg_out <- lapply(scene_names, function(scene_name){
s <- scene_list[[scene_name]]
source("q.ep.weibull.R")
hydro_ep <- q.ep.weibull(s,modeled_q,scene_name)
scene_veg_out$hydro_ep <- hydro_ep
# source("make.inun.q.map.R")
# wet_map <- make.inun.q.map(hydro_ep,out_val_rast,modeled_q,scene_name)
# scene_veg_out$wet_map <- wet_map
source("make.ep.maps.R")
ep_map <- make.ep.maps(hydro_ep,out_val_rast,modeled_q,scene_name)
scene_veg_out$ep_map <- ep_map
# make maps of probability of occurrence of vegetation
all_veg_logit <- fread(paste(reach_wd,"habitat_info","/",reach_name,"_veg_pref",".csv",sep=""),
header=TRUE, sep = ",",data.table = FALSE) # load logistic equations
source("find.veg.logit.R"); source("find.prob.occur.R"); source("make.veg.maps.R")
prob_veg_maps <- lapply(veg_list, function(v) {
one_veg_logit <- find.veg.logit(all_veg_logit,v)
hydro_ep_prob <- find.prob.occur(v,hydro_ep,one_veg_logit) # outputs table of discharge, EP of discharge, and Prob of Veg for discharge
prob_veg_maps <- make.veg.maps(v,ep_map,hydro_ep_prob,scene_name)
return(prob_veg_maps)
})
names(prob_veg_maps) <- veg_list
scene_veg_out$prob_veg_maps <- prob_veg_maps
return(scene_veg_out)
}) # end of flow scenario list function
names(scene_veg_out) <- names(scene_list)
if(LoadScenario == "Yes"){
scene_list <- lapply(scene_names, function(s){
q_ts <- na.omit(fread(file=paste(reach_wd,"flow_scenarios","/",reach_name,"_",s,".csv",sep=""),
header=TRUE, sep = ",",data.table=FALSE)) %>%
mutate(date_form = as.Date(date)) %>%
select(-date) %>%
rename(date = date_form)
if(DateRange=="Yes"){
q_ts <- subset(q_ts, date > as.Date(start_date))
q_ts <- subset(q_ts, date < as.Date(end_date))
}
return(q_ts)
})
names(scene_list) <- scene_names
#scene_list$hydrograph <- hydrograph
scene_names <- names(scene_list) # updated scene name list for labeling
} else{
scene_list <- list(hydrograph)
scene_names <- "hydrograph"
}
scene_list <- list(hydrograph)
scene_names <- "hydrograph"
names(scene_list) <- scene_names
}
scene_veg_out <- list()
scene_veg_out <- lapply(scene_names, function(scene_name){
s <- scene_list[[scene_name]]
source("q.ep.weibull.R")
hydro_ep <- q.ep.weibull(s,modeled_q,scene_name)
scene_veg_out$hydro_ep <- hydro_ep
# source("make.inun.q.map.R")
# wet_map <- make.inun.q.map(hydro_ep,out_val_rast,modeled_q,scene_name)
# scene_veg_out$wet_map <- wet_map
source("make.ep.maps.R")
ep_map <- make.ep.maps(hydro_ep,out_val_rast,modeled_q,scene_name)
scene_veg_out$ep_map <- ep_map
# make maps of probability of occurrence of vegetation
all_veg_logit <- fread(paste(reach_wd,"habitat_info","/",reach_name,"_veg_pref",".csv",sep=""),
header=TRUE, sep = ",",data.table = FALSE) # load logistic equations
source("find.veg.logit.R"); source("find.prob.occur.R"); source("make.veg.maps.R")
prob_veg_maps <- lapply(veg_list, function(v) {
one_veg_logit <- find.veg.logit(all_veg_logit,v)
hydro_ep_prob <- find.prob.occur(v,hydro_ep,one_veg_logit) # outputs table of discharge, EP of discharge, and Prob of Veg for discharge
prob_veg_maps <- make.veg.maps(v,ep_map,hydro_ep_prob,scene_name)
return(prob_veg_maps)
})
names(prob_veg_maps) <- veg_list
scene_veg_out$prob_veg_maps <- prob_veg_maps
return(scene_veg_out)
}) # end of flow scenario list function
names(scene_veg_out) <- names(scene_list)
scene_veg_out$hydrograph$ep_map
spplot(scene_veg_out$hydrograph$ep_map)
source("make.inun.q.map.R")
wet_map <- make.inun.q.map(hydro_ep,out_val_rast,modeled_q,scene_name)
scene_veg_out$wet_map <- wet_map
scene_name <- "hydrograph"
options
rasterOptions()
rasterTmpFile()
?writeRaster
writeRaster(out_val_rast,filename = "out_val_rast_test.tif",format = "GTiff",bylayer=FALSE)
writeRaster(out_val_rast[[1]],filename = "out_val_rast_test.tif",format = "GTiff",bylayer=FALSE)
install.packages("tictoc")
# This script will house the pre-processing options and functionality
# This script will process 2D hydraulic modeling results
# This script will rasterize substrate maps if applicable
# Last edited by Elaina Passero on 11/05/19
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis",
"ggplot2","data.table","dplyr","plotly","spex","stars","igraph","deldir","hydroTSM","rlist")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
# load the installed libraries in the packages list
lapply(packages,library,character.only=TRUE)
## Primary Inputs
wd <- "C:/Users/epassero/Desktop/VRDSS/verde-refdss/" # Project working directory
#wd <- "/Users/Morrison/Documents/Active Research Projects/Verde REFDSS/verde-refdss/" # Set path to local repository
setwd(wd)
hab_mets <- list("Depth","Velocity") #,"Velocity","WaterSurfaceElevation") #Variables from iRIC calculation result used for habitat analysis - case sensitive!
reach_name <- "USBeasley1" # Should match name of folder with results
dis_unit <- "cms" #units of discharge
# Yes- external rasters or No- rasterize iRIC results. Inputs required if No.
LoadExternal <- "No"; if(LoadExternal=="No"){
skip_num <- 0 # number of rows to skip when reading in raw outputs
x_loc <- "X" # field name of X coordinate in model outputs - case sensitive
y_loc <- "Y" # field name of y coordinate in model outputs - case sensitive
dem <- "BeasleyUS_0.25m_20191108.tif" # Name of dem: VerdeBeasley1Elev.tif, smrf_dem_v241.tif, braidallpts_dem.tif, GilaMGnd.tif
# Does the resolution of the rasters need to be manually set? If No, dem resolution will be used.
setRes <- "Yes"; if(setRes=="Yes"){
res <- c(0.5,0.5)} # resolution of rasters if they need to be manually set
}
## Options - If set to No, inputs are not required for option
# Yes or No. Choose whether or not to check substrate conditions as part of suitable habitat
CheckSub <- "Yes"; if(CheckSub=="Yes"){
sub_name <- "BeasleyUS_SedThiessenPoly1Dissolved" # shapefile name with no extension BeasleyUS_SedThiessenPoly1Dissolved
sub_field <- "ParticalSi"} # name of field in substrate map containing substrate type info; ParticalSi or substrate
### Begin Processing ###
reach_wd <- paste(wd,"reaches","/",reach_name,"/",sep = "")
rasterOptions(overwrite = TRUE,tmpdir = paste(reach_wd,"temp/",sep=""))
pre_outputs <- list()
if(LoadExternal == "No"){
## Format result CSVs and get list of discharges
source("get.results.R")
temp_list <- get.results(reach_wd,skip_num,dis_unit)
delim_list <- temp_list$delim_list
modeled_q <- temp_list$modeled_q
rm(temp_list)
## Convert iRIC outputs to rasterBricks by variable
source("iric.process.smr.R")
out_val_rast <- list()
out_val_rast <- lapply(hab_mets, function(m) iric.process.smr(m,delim_list,reach_wd,dem,setRes,x_loc,y_loc))
names(out_val_rast) <-hab_mets
rm(delim_list)
} else{
## Load in external rasterBricks and discharges
source("load.cherry.R")
out_val_rast <- load.cherry(reach_wd,Check0Flow)
names(out_val_rast)<-c(hab_mets,"modeled_q")
modeled_q <- out_val_rast$modeled_q
out_val_rast[length(out_val_rast)]<-NULL
}
pre_outputs$out_val_rast <- out_val_rast
pre_outputs$modeled_q <- modeled_q
## Load substrate
if(CheckSub == "Yes"){
base_rast <- out_val_rast[[1]][[1]] # will be overwritten during rasterization - provides setup
sub_map <- readOGR(dsn=paste(wd,"reaches", "/", reach_name, sep=""),layer=sub_name) # read in substrate shapefile
rast_sub_map <- rasterize(sub_map,base_rast,field=sub_map@data[[sub_field]],update=TRUE)
pre_outputs$rast_sub_map <- rast_sub_map
}
# save outputs for internal use
list.save(pre_outputs,file=paste(reach_wd,reach_name,"_pre_outputs.rdata",sep=""))
