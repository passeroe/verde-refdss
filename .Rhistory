plot(tpoSpdf)
head(tpoOut)
plot(epoly)
plot(gridBound)
#import .tpo data
iricOutPath <- "U:\\iRIC tutorials\\outputs\\"
tpoOut <-fread(paste(iricOutPath,"chris_results1_Elevation",".tpo",sep = ""), header=FALSE, sep=",")
#create raster from .tpo
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,c(1,2)],tpoOut[,3])
rastHold <- raster()
extent(rastHold)<-extent(tpoSpdf)
#iRIC sample data missing CRS info
crs(rastHold)<-proj4string(tpoSpdf)
#intersect grid outline and voronoi polygons
get.grid(iricOutPath)
vorgrid <- voronoi(tpoSpdf)
gridcut <- intersect(vorgrid,gridBound)
spplot(gridcut,colorkey=TRUE)
source("get.grid.R")
get.grid(iricOutPath)
do.call(get.grid, iricOutPath)
call(get.grid)
#begin function
get.grid <- function(iricOutPath){
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
gridBound <- SpatialPolygons(list(epoly))
return(gridBound)
}
get.grid(iricOutPath)
vorgrid <- voronoi(tpoSpdf)
gridcut <- intersect(vorgrid,gridBound)
spplot(gridcut,colorkey=TRUE)
library("deldir", lib.loc="U:/R/win-library/3.4")
library("dismo", lib.loc="U:/R/win-library/3.4")
vorgrid <- voronoi(tpoSpdf)
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#import iRIC calculation grid .csv
iricOutPath <- "U:\\iRIC tutorials\\outputs\\"
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
gridBound <- SpatialPolygons(list(epoly))
return(gridBound)
#begin function
get.grid <- function(iricOutPath){
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
gridBound <- SpatialPolygons(list(epoly))
return(gridBound)
} #end get.grid function
#intersect grid outline and voronoi polygons
gridxy <- SpatialPointsDataFrame(gridcsv[,3:4],gridcsv[,2])
vorgrid <- voronoi(gridxy)
tpoOut <-fread(paste(iricOutPath,"chris_results1_Elevation",".tpo",sep = ""), header=FALSE, sep=",")
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,c(1,2)],tpoOut[,3])
class(gridcsv)
class(tpoSpdf)
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,1:3])
#create raster from .tpo
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,1:2],tpoOut[,3])
vorgrid <- voronoi(tpoSpdf)
tpoSpdf[,1:2]
tpoSpdf$V3
gridxy[,3]
gridxy$J
voronoi(tpoSpdf)
deldir(tpoSpdf)
deldir(gridxy)
View(tpoOut)
View(gridcsv)
names(tpoSpdf) <-c("X","Y","Z")
View(gridcsv)
View(tpoOut)
names(tpoOut) <-c("X","Y","Z")
View(tpoOut)
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,1:2],tpoOut[,3])
vorgrid <- voronoi(tpoSpdf)
.libpaths()
.libPaths()
myPaths <- .libPaths()   # get the paths
myPaths <- c(myPaths[2], myPaths[1])  # switch them
.libPaths(myPaths)  # reassign them
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis","ggplot2","data.table","dpylr","plotly")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
library
help("Startup")
.libPaths()
.libPaths()
install.packages("dataRetrieval")
install.packages("FlowScreen")
install.packages("hydroTSM")
# Function: This script serves as the master script that controls which functions are run and what inputs are used for finding suitable fish habitat
#         It will later be converted to the script that controls the Shiny App.
# Last edited by Elaina Passero on 06/03/19
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis",
"ggplot2","data.table","dplyr","plotly","spex","stars","igraph","deldir","hydroTSM")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
# load the installed libraries in the packages list
lapply(packages,library,character.only=TRUE)
### Begin Inputs ###
## Primary Inputs
wd <- "C:/Users/epassero/Desktop/VRDSS/verde-refdss/"
#wd <- "/Users/Morrison/Documents/Active Research Projects/Verde REFDSS/verde-refdss/" # Set path to local repository
setwd(wd)
habMets <- list("Depth","Velocity") #Variables from iRIC calculation result used for habitat analysis ex: Velocity..magnitude.
specieslist <- c("longfindace","yellowbullhead","desertsucker","sonoransucker","redshiner","roundtailchub","greensunfish","fatheadminnow","speckleddace")
species <- "longfindace"
lifestages <- list("adult") #lifestages from oldest to youngest; must match order in HSC table
reachName <- "Beasley1" # Should match name of folder with results
disunit <- "cms" #units of discharge
## Secondary Inputs - Use only if switching between projects
Check0Flow <- "No" # Yes- Calculate max area for 0-flow scenario and interpolate below min modeled Q
# Yes- external rasters or No- rasterize iRIC results. Inputs required if No.
LoadExternal <- "No"; if(LoadExternal=="No"){
skipnum <- 2 # number of rows to skip when reading in CSV results
xLoc <- "X" # field name of X coordinate in CSVs
yLoc <- "Y" # field name of y coordinate in CSVs
DEM <- "VerdeBeasley1Elev.tif" # Name of DEM: VerdeBeasley1Elev.tif, smrf_DEM_v241.tif, braidallpts_DEM.tif, GilaMGnd.tif
# Does the resolution of the rasters need to be manually set? If No, DEM resolution will be used.
setRes <- "No"; if(setRes=="Yes"){
res <- c(10,10)} # resolution of rasters if they need to be manually set
if(Check0Flow=="Yes"){
depth0Flow <- "insert depth raster layer"
}# end of internal rasterization inputs;
}
## Options - If set to No, inputs are not required for option
# Yes or No. Choose whether or not to check substrate conditions as part of suitable habitat
CheckSub <- "Yes"; if(CheckSub=="Yes"){
subName <- "BeasleyUS_SedThiessenPoly1Dissolved"}
# Yes or No. Choose whether or not to remove isolated (single cell) habitat patches
RemoveIslands <- "Yes"; if(RemoveIslands=="Yes"){
islandSize <- 2} # number of raster cells that is considered too small of a habitat patch
# Yes or No. Choose whether or not to normalize habitat area by reach length
NormalizeByL <- "No"; if(NormalizeByL=="Yes"){
reachL <- 0.61
unitL <- "km"} # Reach length in km. If not normalizing set equal to 1.
# Yes or No. Will a hydrograph be supplied? If "No" CalcXDayStats and DateRange can be left blank.
FlowScenario <- "Yes"; if(FlowScenario=="Yes"){
# Yes or No. Choose whether or not to calculate X-day statistics. Must supply number of days.
CalcXDayStats <- "No"; if(CalcXDayStats=="Yes"){
xDays <- 7} # number of days for moving discharge and area statistics
# Yes or No. Yes - limit analysis to supplied dates. No - consider entire hydrograph.
DateRange <- "No"; if(DateRange=="Yes"){
startDate <- "1993-10-01" # "YYYY-MM-DD"
endDate <- "1994-03-30"} # "YYYY-MM-DD"
} # End of flow scenario related options
### Begin Processing ###
if(LoadExternal == "No"){
## Format result CSVs and get list of discharges
source("get.results.R")
holdList <- get.results(wd,reachName,skipnum,disunit)
csvList <- holdList$csvList
modeled_q <- holdList$modeled_q
rm(holdList)
### for cherry Creek ###
#source("exp.shp.R")
#resultsPts <- lapply(habMets, function(a) exp.shp(a,csvList,wd,DEM,reachName,xLoc,yLoc))
## Convert iRIC outputs to rasterBricks by variable
source("iric.process.smr.R")
outValRast <- list()
outValRast <- lapply(habMets, function(m) iric.process.smr(m,csvList,wd,DEM,reachName,setRes,xLoc,yLoc))
names(outValRast) <-habMets
rm(csvList)} else{
## Load in external rasterBricks and discharges
source("load.cherry.R")
#reachCode <- "del1"
outValRast <- load.cherry(wd,reachName,reachCode)
names(outValRast)<-c(habMets,"modeled_q")
modeled_q <- outValRast$modeled_q
outValRast[length(outValRast)]<-NULL
}
## Read in hydrograph if one is supplied
if(FlowScenario == "Yes"){
hydrograph <- na.omit(fread(paste(wd,reachName,"_hydrograph",".csv",sep=""),header=TRUE, sep = ",",data.table=FALSE))
hydrograph$date <- as.Date(hydrograph$date, format="%m/%d/%Y")
if(DateRange=="Yes"){
hydrograph <- subset(hydrograph, date > as.Date(startDate))
hydrograph <- subset(hydrograph, date < as.Date(endDate))
}
}
## Load substrate
if(CheckSub == "Yes"){
baseRast <- outValRast[[1]][[1]] # will be overwritten during rasterization - provides setup
subMap <- readOGR(dsn=paste(wd,"results","/",reachName,sep = ""),layer=subName) # read in substrate shapefile
#rastSubMap <- rasterize(subMap,baseRast,field=subMap@data$substrate,update=TRUE)
rastSubMap <- rasterize(subMap,baseRast,field=subMap@data$ParticalSi,update=TRUE)
}
##### Run for all species #####
outputs <- list()
outputs <- lapply(specieslist, function(species){ # builds tables and maps for all species in list
## Reclassify Bricks with hydraulic and substrate HSC by lifestage
source("find.hsc.R"); source("bricks.rc.R"); source("by.substrate.R"); source("find.sub.R"); source("remove.islands.R")
hsc_allspec<-fread(paste(wd,reachName,"_hsc",".csv",sep = ""), header=TRUE, sep=",",data.table = FALSE)
hsc_allages <- find.hsc(hsc_allspec,species) # extract HSC for single species
goodHabList <- lapply(lifestages, function(a) bricks.rc(a,outValRast,hsc_allages,habMets))
names(goodHabList) <- lifestages # list of Bricks by lifestage
# Not sure if this is working correctly yet
if(CheckSub == "Yes"){
sub_allspec <- fread(paste(wd,reachName,"_substrate",".csv",sep=""),header=TRUE, sep = ",",data.table = FALSE) # load substrate requirements
sub_allages <- find.sub(sub_allspec,species) # extract substrate requirements for single species
goodHabList <- lapply(lifestages, function(a) by.substrate(a, goodHabList, sub_allages,rastSubMap))
names(goodHabList) <- lifestages
} # end of if statement
if(RemoveIslands == "Yes"){
goodHabList <- lapply(lifestages, function(a) remove.islands(a,goodHabList,RemoveIslands,islandSize))
names(goodHabList) <- lifestages
}
## Total available habitat area by lifestage
source("total.area.R")
areaLookTab <- lapply(lifestages, function(a) total.area(a,goodHabList,modeled_q,NormalizeByL,reachL,habMets))
names(areaLookTab) <- lifestages
## Order rasters of total available habitat by modeled discharge
source("rast.by.q.R")
rastByQ <- lapply(lifestages, function(a) rast.by.q(a,goodHabList,modeled_q))
names(rastByQ) <- lifestages
## Generate Interpolated Discharge-Area Lookup Tables from Hydrograph and Regression if hydrograph provided
if(FlowScenario=="Yes"){
source("interp.table.R")
interTab <- lapply(lifestages, function(a) interp.table(a,hydrograph,areaLookTab,NormalizeByL))
names(interTab) <- lifestages
## Generate and view plots of total area through the hydrograph
#source("interp.plot.R")
#interPlots <- lapply(lifestages, function(a) interp.plot(a,interTab,NormalizeByL))
#head(interPlots)
## Generate Data Frames of moving X-Day area and discharge statistics
if(CalcXDayStats=="Yes"){
source("x.day.stats.R")
xDayStats <- lapply(lifestages, function(a) x.day.stats(a,interTab,xDays))
names(xDayStats) <- lifestages
}
source("avg.month.area.R")
avgMonthlyArea <- lapply(lifestages, function(a) avg.month.area(a,interTab,NormalizeByL))
names(avgMonthlyArea) <- lifestages
# end of flow scenario dependent processes
# condense outputs into single list
outputs$areaLookTab <- areaLookTab
outputs$rastByQ <- rastByQ
outputs$avgMonthlyArea <- avgMonthlyArea
} else{ # outputs not including any flow-scenario related outputs
# condense outputs into a single list
outputs$areaLookTab <- areaLookTab
outputs$rastByQ <- rastByQ
}
return(outputs)
}) # end of species list function
names(outputs) <- specieslist
# Put tables in a nice format
tables <- lapply(specieslist, function(species){
outputs[[species]]$areaLookTab
})
names(tables) <- specieslist
install.packages("mgcv")
# read in historical flow record
hydrograph <- na.omit(fread(paste(wd,reachName,"_hydrograph",".csv",sep=""),header=TRUE, sep = ",",data.table=FALSE))
hydrograph$date <- as.Date(hydrograph$date, format="%m/%d/%Y")
# calculate exceedence probability
hydroEP <- data.frame(discharge = hydrograph$discharge,rank=rank(-hydrograph$discharge,ties.method = "min")) # ranks discharges; same values get same ranks
n <- as.numeric(length(hydroEP$discharge))
hydroEP$EP <- hydroEP$rank/(1+n)
#         It will later be converted to the script that controls the Shiny App.
# Last edited by Elaina Passero on 06/03/19
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis",
"ggplot2","data.table","dplyr","plotly","spex","stars","igraph","deldir","hydroTSM")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
# load the installed libraries in the packages list
lapply(packages,library,character.only=TRUE)
# read in historical flow record
hydrograph <- na.omit(fread(paste(wd,reachName,"_hydrograph",".csv",sep=""),header=TRUE, sep = ",",data.table=FALSE))
hydrograph$date <- as.Date(hydrograph$date, format="%m/%d/%Y")
# calculate exceedence probability
hydroEP <- data.frame(discharge = hydrograph$discharge,rank=rank(-hydrograph$discharge,ties.method = "min")) # ranks discharges; same values get same ranks
n <- as.numeric(length(hydroEP$discharge))
hydroEP$EP <- hydroEP$rank/(1+n)
View(hydroEP)
# Taking a swing at GAM
library(mgcv)
x <- hydroEP$discharge
y <- hydroEP$EP
model <- gam(y~s(x),data=hydroEP)
plot(model)
predictions <- model %>% predict(modeled_q)
x <- hydroEP$discharge
y <- hydroEP$EP
model <- gam(y~s(x),data=hydroEP)
plot(model)
predictions <- mgcv::predict(model,modeled_q)
predictions <- mgcv::predict.gam(model,modeled_q)
predictions <- mgcv::predict.gam(model,data.frame(modeled_q))
predictions <- mgcv::predict.gam(model,hydroEP)
plot(predictions)
ggplot(hydroEP, aes(x=x,y=y))+
geom_point()+
stat_smooth(method=gam, formula=y~s(x))
predictions
# Selecting the bottom 0.5% to fit a curve through it
backEnd <- subset(hydroEP,hydroEP$EP < 0.005)
x <- backEnd$discharge
y <- backEnd$EP
model <- gam(y~s(x),data=backEnd)
plot(model)
predictions <- mgcv::predict.gam(model,backEnd)
ggplot(backEnd, aes(x=x,y=y))+
geom_point()+
stat_smooth(method=gam, formula=y~s(x))
x <- backEnd$discharge
y <- backEnd$EP
model <- gam(y~s(x),data=backEnd)
plot(model)
predictions <- mgcv::predict.gam(model,backEnd)
predictions
data.frame(predictions)
extraps <- mgcv::predict.gam(model,modeled_q)
# Taking a swing at GAM
library(mgcv)
x <- backEnd$discharge
y <- backEnd$EP
model <- gam(y~s(x),data=backEnd)
plot(model)
predictions <- mgcv::predict.gam(model,backEnd)
ggplot(backEnd, aes(x=x,y=y))+
geom_point()+
stat_smooth(method=gam, formula=y~s(x))
modeled_q
extraQ <- data.frame(discharge=c(50000,60000,65000,68000,70000))
extrap <- predict.gam(model,extraQ)
extrap <- predict.gam(model,extraQ,type="terms")
extrap
# Taking a swing at GAM
library(mgcv)
gamTest <- data.frame(x=backEnd$discharge,y=backEnd$EP)
model <- gam(y~s(x),data=gamTest)
plot(model)
predictions <- mgcv::predict.gam(model,gamTest)
ggplot(gamTest, aes(x=x,y=y))+
geom_point()+
stat_smooth(method=gam, formula=y~s(x))
extraP <- mgcv::predict.gam(model,extraQ)
rm(extraP)
rm(extrap)
extraP <- mgcv::predict.gam(model,extraQ)
install.packages("scam")
gamLo <- gam.lo(x=x,y=y,ncols=1)
install.packages("gam")
gamLo <- gam.lo(x=x,y=y,ncols=1)
# gam.lo from gam package
library(gam)
# Taking a swing at GAM
library(mgcv)
gamTest <- data.frame(x=backEnd$discharge,y=backEnd$EP)
model <- gam(y~s(x),data=gamTest)
plot(model)
predictions <- mgcv::predict.gam(model,gamTest)
extraQ <- data.frame(discharge=c(50000,55000,60000,65000,70000,75000))
extraP <- mgcv::predict.gam(model,extraQ) # still returns values from origina
gamTest <- data.frame(x=backEnd$discharge,y=backEnd$EP)
model <- gam(y~s(x),data=gamTest)
plot(model)
predictions <- mgcv::predict.gam(model,gamTest)
extraQ <- data.frame(discharge=c(50000,55000,60000,65000,70000,75000))
extraP <- mgcv::predict.gam(model,extraQ) # still returns values from original dataset
library(mgcv)
gamTest <- data.frame(x=backEnd$discharge,y=backEnd$EP)
model <- gam(y~s(x),data=gamTest)
plot(model)
predictions <- mgcv::predict.gam(model,gamTest)
gamTest <- data.frame(x=backEnd$discharge,y=backEnd$EP)
model <- gam(y~s(x),data=gamTest)
plot(model)
predictions <- mgcv::predict.gam(model,gamTest)
gamTest <- data.frame(x=backEnd$discharge,y=backEnd$EP)
model <- mgcv::gam(y~s(x),data=gamTest)
plot(model)
predictions <- mgcv::predict.gam(model,gamTest)
extraQ <- data.frame(discharge=c(50000,55000,60000,65000,70000,75000))
extraP <- mgcv::predict.gam(model,extraQ) # still returns values from original dataset
?mgcv::predict.gam()
n<-200
sig <- 2
x0 <- runif(n, 0, 1)
x1 <- runif(n, 0, 1)
x2 <- runif(n, 0, 1)
x3 <- runif(n, 0, 1)
y <- 2 * sin(pi * x0)
y <- y + exp(2 * x1)
y <- y + 0.2 * x2^11 * (10 * (1 - x2))^6 + 10 * (10 * x2)^3 * (1 - x2)^10
y <- y + x3
e <- rnorm(n, 0, sig)
y <- y + e
b<-gam(y~s(x0)+s(I(x1^2))+s(x2)+offset(x3))
b
model
y
rm(y,x0,x1,x2,x3)
newd <- data.frame(x0=(0:30)/30,x1=(0:30)/30,x2=(0:30)/30,x3=(0:30)/30)
newd
pred <- predict.gam(b,newd)
pred <- mgcv::predict.gam(b,newd)
n<-200
sig <- 2
x0 <- runif(n, 0, 1)
x1 <- runif(n, 0, 1)
x2 <- runif(n, 0, 1)
x3 <- runif(n, 0, 1)
y <- 2 * sin(pi * x0)
y <- y + exp(2 * x1)
y <- y + 0.2 * x2^11 * (10 * (1 - x2))^6 + 10 * (10 * x2)^3 * (1 - x2)^10
y <- y + x3
e <- rnorm(n, 0, sig)
y <- y + e
b<-gam(y~s(x0)+s(I(x1^2))+s(x2)+offset(x3))
rm(y,x0,x1,x2,x3)
newd <- data.frame(x0=(0:30)/30,x1=(0:30)/30,x2=(0:30)/30,x3=(0:30)/30)
pred <- mgcv::predict.gam(b,newd)
b<-mgcv::gam(y~s(x0)+s(I(x1^2))+s(x2)+offset(x3))
rm(y,x0,x1,x2,x3)
newd <- data.frame(x0=(0:30)/30,x1=(0:30)/30,x2=(0:30)/30,x3=(0:30)/30)
pred <- mgcv::predict.gam(b,newd)
n<-200
sig <- 2
x0 <- runif(n, 0, 1)
x1 <- runif(n, 0, 1)
x2 <- runif(n, 0, 1)
x3 <- runif(n, 0, 1)
y <- 2 * sin(pi * x0)
y <- y + exp(2 * x1)
y <- y + 0.2 * x2^11 * (10 * (1 - x2))^6 + 10 * (10 * x2)^3 * (1 - x2)^10
y <- y + x3
e <- rnorm(n, 0, sig)
y <- y + e
b<-mgcv::gam(y~s(x0)+s(I(x1^2))+s(x2)+offset(x3))
rm(y,x0,x1,x2,x3)
newd <- data.frame(x0=(0:30)/30,x1=(0:30)/30,x2=(0:30)/30,x3=(0:30)/30)
pred <- mgcv::predict.gam(b,newd)
pred
gamTest <- data.frame(x=backEnd$discharge,y=backEnd$EP)
model <- mgcv::gam(y~s(x),data=gamTest)
plot(model)
predictions <- mgcv::predict.gam(model,gamTest)
extraQ <- data.frame(discharge=c(50000,55000,60000,65000,70000,75000), EP=c(0.5,.5,.5,.5,.5,.5))
extraP <- mgcv::predict.gam(model,extraQ) # still returns values from original dataset
extraQ <- data.frame(x=c(50000,55000,60000,65000,70000,75000), EP=c(0.5,.5,.5,.5,.5,.5))
extraP <- mgcv::predict.gam(model,extraQ) # still returns values from original dataset
extraP
plot(extraP)
ggplot(gamTest, aes(x=x,y=y))+
geom_point()+
stat_smooth(method=gam, formula=y~s(x))+
geom_point(extraP)
ggplot(gamTest, aes(x=x,y=y))+
geom_point()+
stat_smooth(method=gam, formula=y~s(x))
plot(model)
predictions
# read in historical flow record
hydrograph <- na.omit(fread(paste(wd,reachName,"_hydrograph",".csv",sep=""),header=TRUE, sep = ",",data.table=FALSE))
hydrograph$date <- as.Date(hydrograph$date, format="%m/%d/%Y")
# calculate exceedence probability
hydroEP <- data.frame(discharge = hydrograph$discharge,rank=rank(-hydrograph$discharge,ties.method = "min")) # ranks discharges; same values get same ranks
n <- as.numeric(length(hydroEP$discharge))
hydroEP$EP <- hydroEP$rank/(1+n)
# Selecting the bottom 0.5% to fit a curve through it
backEnd <- subset(hydroEP,hydroEP$EP < 0.005)
x <- backEnd$discharge
y <- backEnd$EP
View(hydroEP)
gamTest <- data.frame(x=backEnd$discharge,y=backEnd$EP)
model <- mgcv::gam(y~s(x),data=gamTest)
plot(model)
predictions <- mgcv::predict.gam(model,gamTest)
extraQ <- data.frame(x=c(50000,55000,60000,65000,70000,75000))
extraP <- mgcv::predict.gam(model,extraQ) # still returns values from original dataset
extraP
1/backEnd[[4]]
1/extraP[[4]]
View(hydrograph)
plot(hydrograph)
