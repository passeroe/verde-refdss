plot(idwOut)
rastXYZ <- rasterize(tpoSpdf,rastHold,tpoSpdf$V3)
plot(rastXYZ)
gridxy <- SpatialPointsDataFrame(gridcsv[,3:4],gridcsv[,2])
vorgrid <- voronoi(gridxy)
gridcut <- intersect(vorgrid,gridBound)
gridBound <-gSimplify(epoly, tol=0.0001)
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
epoly <- SpatialPolygons(list(epoly))
gridBound <-gSimplify(epoly, tol=0.0001)
gridcut <- intersect(vorgrid,gridBound)
plot(gridcut)
plot(gridxy)
spplot(gridcut,J,colorkey=TRUE)
spplot(gridcut,gricut$J,colorkey=TRUE)
spplot(gridcut,gridcut$J,colorkey=TRUE)
spplot(gridcut,gridcut[,1],colorkey=TRUE)
spplot(gridcut,zcol=gridcut[,1],colorkey=TRUE)
spplot(gridcut,colorkey=TRUE)
plot(tpoSpdf)
head(tpoOut)
plot(epoly)
plot(gridBound)
#import .tpo data
iricOutPath <- "U:\\iRIC tutorials\\outputs\\"
tpoOut <-fread(paste(iricOutPath,"chris_results1_Elevation",".tpo",sep = ""), header=FALSE, sep=",")
#create raster from .tpo
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,c(1,2)],tpoOut[,3])
rastHold <- raster()
extent(rastHold)<-extent(tpoSpdf)
#iRIC sample data missing CRS info
crs(rastHold)<-proj4string(tpoSpdf)
#intersect grid outline and voronoi polygons
get.grid(iricOutPath)
vorgrid <- voronoi(tpoSpdf)
gridcut <- intersect(vorgrid,gridBound)
spplot(gridcut,colorkey=TRUE)
source("get.grid.R")
get.grid(iricOutPath)
do.call(get.grid, iricOutPath)
call(get.grid)
#begin function
get.grid <- function(iricOutPath){
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
gridBound <- SpatialPolygons(list(epoly))
return(gridBound)
}
get.grid(iricOutPath)
vorgrid <- voronoi(tpoSpdf)
gridcut <- intersect(vorgrid,gridBound)
spplot(gridcut,colorkey=TRUE)
library("deldir", lib.loc="U:/R/win-library/3.4")
library("dismo", lib.loc="U:/R/win-library/3.4")
vorgrid <- voronoi(tpoSpdf)
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#import iRIC calculation grid .csv
iricOutPath <- "U:\\iRIC tutorials\\outputs\\"
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
gridBound <- SpatialPolygons(list(epoly))
return(gridBound)
#begin function
get.grid <- function(iricOutPath){
gridcsv <-fread(paste(iricOutPath,"calcgrid",".csv",sep = ""), header=TRUE, sep=",",skip=2,drop=c("K","Z"))
#get points on edges of grid
edge3<-gridcsv %>% filter(J == 0)
edge4<-gridcsv %>% filter(J == max(gridcsv[,2]))
#flip the order of the data frame
edge4<-edge4[dim(edge4)[1]:1,]
#create polygon from grid edges
edges <-distinct(rbind(edge3[,3:4],edge4[,3:4]))
epoly <- Polygon(edges)
epoly <- Polygons(list(epoly),1)
gridBound <- SpatialPolygons(list(epoly))
return(gridBound)
} #end get.grid function
#intersect grid outline and voronoi polygons
gridxy <- SpatialPointsDataFrame(gridcsv[,3:4],gridcsv[,2])
vorgrid <- voronoi(gridxy)
tpoOut <-fread(paste(iricOutPath,"chris_results1_Elevation",".tpo",sep = ""), header=FALSE, sep=",")
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,c(1,2)],tpoOut[,3])
class(gridcsv)
class(tpoSpdf)
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,1:3])
#create raster from .tpo
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,1:2],tpoOut[,3])
vorgrid <- voronoi(tpoSpdf)
tpoSpdf[,1:2]
tpoSpdf$V3
gridxy[,3]
gridxy$J
voronoi(tpoSpdf)
deldir(tpoSpdf)
deldir(gridxy)
View(tpoOut)
View(gridcsv)
names(tpoSpdf) <-c("X","Y","Z")
View(gridcsv)
View(tpoOut)
names(tpoOut) <-c("X","Y","Z")
View(tpoOut)
tpoSpdf <- SpatialPointsDataFrame(tpoOut[,1:2],tpoOut[,3])
vorgrid <- voronoi(tpoSpdf)
.libpaths()
.libPaths()
myPaths <- .libPaths()   # get the paths
myPaths <- c(myPaths[2], myPaths[1])  # switch them
.libPaths(myPaths)  # reassign them
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis","ggplot2","data.table","dpylr","plotly")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
library
help("Startup")
.libPaths()
.libPaths()
install.packages("dataRetrieval")
install.packages("FlowScreen")
install.packages("hydroTSM")
a <- "d_cfs_4.8m.tif"
# Function: This script serves as the master script that controls which functions are run and what inputs are used for finding suitable fish habitat
#         It will later be converted to the script that controls the Shiny App.
# Last edited by Elaina Passero on 04/29/19
# Load required packages
packages <- c("SDMTools","sp","raster","rgeos","rgdal","sf","spatstat","spdep","tidyverse","rasterVis",
"ggplot2","data.table","dplyr","plotly","spex","stars","igraph")
#  Check to see if each is installed, and install if not.
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
# load the installed libraries in the packages list
lapply(packages,library,character.only=TRUE)
# Set Inputs
wd <- "C:/Users/epassero/Desktop/VRDSS/verde-refdss/"
#wd <- "/Users/Morrison/Documents/Active Research Projects/Verde REFDSS/verde-refdss/" # Set path to local repository
setwd(wd)
habMets <- list("depth","velocity") #Variables from iRIC calculation result used for habitat analysis ex: Velocity..magnitude.
species <- "longfindace"
lifestages <- list("adult") #lifestages from oldest to youngest; must match order in HSC table
reachName <- "Cherry_Braid" # Should match name of folder with results
DEM <- "braidallpts_DEM.tif" # Name of DEM used in iRIC: VerdeBeasley1Elev.tif or smrf_DEM_v241.tif or braidallpts_DEM.tif. If loading externally put NA
disunit <- "cfs" #units of discharge
reachL <- NULL
subName <- shpName
parse_number(a)
tempwd <-paste(wd,"results","/",reachName,"/","rasters",sep = "") # Rasters must be in their own folder
setwd(tempwd)
depthRast <- as.list(list.files(path=paste(tempwd,"depth","/",sep=""),pattern = "m.tif")) # pull depth rasters
velRast <- as.list(list.files(path=paste(tempwd,"velocity","/",sep=""),pattern = "m.tif")) # pull velocity rasters
depthRast <- as.list(list.files(path=paste(tempwd,"depth","/",sep=""),pattern = "m.tif")) # pull depth rasters
velRast <- as.list(list.files(path=paste(tempwd,"velocity","/",sep=""),pattern = "m.tif")) # pull velocity rasters
tempwd <-paste(wd,"results","/",reachName,"/",sep = "") # Rasters must be in their own folder
depthRast <- as.list(list.files(path=paste(tempwd,"depth","/",sep=""),pattern = "m.tif")) # pull depth rasters
velRast <- as.list(list.files(path=paste(tempwd,"velocity","/",sep=""),pattern = "m.tif")) # pull velocity rasters
a <- "v_cfs_4_8m.tif"
parse_number(a)
depthRast <- as.list(list.files(path=paste(tempwd,"depth","/",sep=""),pattern = "m.tif")) # pull depth rasters
# get list of modeled discharges
modeled_q <- c()
modeled_q <- parse_number(depthRast)
modeled_q <- lapply(depthRast, parse_number)
modeled_q <- unlist(lapply(depthRast, parse_number))
depthRast <- brick(lapply(depthRast,raster))
setwd(tempwd)
depthRast <- brick(lapply(depthRast,raster))
tempwd <- paste(tempwd,"depth","/",sep="")
setwd(tempwd)
depthRast <- brick(lapply(depthRast,raster))
tenkrast <- raster(depthRast[[1]])
depthRast[[14]]
fourrast <- raster(depthRast[[14]])
extent(fourrast)
extent(tenkrast)
brick(tenkrast,fourrast)
compareRaster(tenkrast,fourrast)
depthRast <- lapply(depthRast,raster)
compareRaster(tenkrast,depthRast)
compRast <- lapply(depthRast, compareRaster(tenkrast,depthRast))
compRast <- lapply(depthRast, compareRaster(tenkrast,b))
compRast <- lapply(depthRast, compareRaster)
warnings()
View(compRast)
compRast <- lapply(depthRast, function(b) compareRaster(tenkrast,b))
compRast <- lapply(depthRast, function(b) compareRaster(tenkrast,b))
compRast <- lapply(depthRast, function(b) compareRaster(tenkrast,b,stopiffalse = FALSE))
View(depthRast)
tempwd <-paste(wd,"results","/",reachName,"/",sep = "") # Rasters must be in their own folder
setwd(tempwd)
depthRast <- as.list(list.files(path=paste(tempwd,"depth","/",sep=""),pattern = "m.tif")) # pull depth rasters
# load rasters
depthRast <- brick(lapply(depthRast,function(b) raster(x=paste(tempwd,"depth","/",b,sep=""))))
rm(compRast)
rm(fourrast)
rm(tenkrast)
rm(velRast)
rm(a)
rm(depthRast)
hsc_allspec<-fread(paste(wd,reachName,"_hsc",".csv",sep = ""), header=TRUE, sep=",",data.table = FALSE)
specieslist <- names(hsc_allspec)
specieslist <- hsc_allspec$V1
specieslist <- grep("adult",hsc_allspec$V1)
specieslist <- grep("adult",hsc_allspec$V1,value=TRUE)
specieslist <- sub("adult","",hsc_allspec$V1)
specieslist <- sub("adult_","",hsc_allspec$V1)
# Set Inputs
wd <- "C:/Users/epassero/Desktop/VRDSS/verde-refdss/"
#wd <- "/Users/Morrison/Documents/Active Research Projects/Verde REFDSS/verde-refdss/" # Set path to local repository
setwd(wd)
habMets <- list("depth","velocity") #Variables from iRIC calculation result used for habitat analysis ex: Velocity..magnitude.
species <- specieslist
lifestages <- list("adult") #lifestages from oldest to youngest; must match order in HSC table
reachName <- "Cherry_Braid" # Should match name of folder with results
DEM <- "braidallpts_DEM.tif" # Name of DEM used in iRIC: VerdeBeasley1Elev.tif or smrf_DEM_v241.tif or braidallpts_DEM.tif. If loading externally put NA
disunit <- "cfs" #units of discharge
reachL <- 0.61
# Set Inputs
wd <- "C:/Users/epassero/Desktop/VRDSS/verde-refdss/"
#wd <- "/Users/Morrison/Documents/Active Research Projects/Verde REFDSS/verde-refdss/" # Set path to local repository
setwd(wd)
habMets <- list("depth","velocity") #Variables from iRIC calculation result used for habitat analysis ex: Velocity..magnitude.
species <- specieslist
lifestages <- list("adult") #lifestages from oldest to youngest; must match order in HSC table
reachName <- "Cherry_Braid" # Should match name of folder with results
DEM <- "braidallpts_DEM.tif" # Name of DEM used in iRIC: VerdeBeasley1Elev.tif or smrf_DEM_v241.tif or braidallpts_DEM.tif. If loading externally put NA
disunit <- "cfs" #units of discharge
reachL <- 0.61
#subName <- shpName
# Secondary Inputs - Use only if switching between projects
skipnum <- 1 # number of rows to skip when reading in CSV results
setRes <- "No" # Does the resolution need to be manually set?
res <- c(0.25,0.25) # resolution of rasters if they need to be manually set
xLoc <- "x" # field name of X coordinate in CSVs
yLoc <- "y" # field name of y coordinate in CSVs
# Options: Do not use CheckSub right now
CheckSub <- "Yes" # Yes or No. Choose whether or not to check substrate conditions as part of suitable habitat
LoadExternal <- "Yes" # Yes- external rasters or No- rasterize iRIC results.
RemoveIslands <- "Yes" # Yes or No. Choose whether or not to remove isolated (single cell) habitat patches
NormalizeByL <- "Yes" # Yes or No. Choose whether or not to normalize habitat area by reach length
if(LoadExternal == "No"){
## Format result CSVs and get list of discharges
source("get.results.R")
holdList <- get.results(wd,reachName,skipnum,disunit)
csvList <- holdList$csvList
modeled_q <- holdList$modeled_q
rm(holdList)
### for cherry Creek ###
#source("exp.shp.R")
#resultsPts <- lapply(habMets, function(a) exp.shp(a,csvList,wd,DEM,reachName,xLoc,yLoc))
## Convert iRIC outputs to rasterBricks by variable
source("iric.process.smr.R")
outValRast <- list()
outValRast <- lapply(habMets, function(a) iric.process.smr(a,csvList,wd,DEM,reachName,setRes,xLoc,yLoc))
names(outValRast) <-habMets
rm(csvList)} else{
## Load in external rasterBricks and discharges
source("load.cherry.R")
#reachCode <- "del1"
outValRast <- load.cherry(wd,reachName,reachCode)
names(outValRast)<-c(habMets,"modeled_q")
modeled_q <- outValRast$modeled_q
outValRast[length(outValRast)]<-NULL
}
##### Run for all species #####
outputs <- list()
outputs <- lapply(specieslist, function(species){ # builds tables and maps for all species in list
## Reclassify Bricks with hydraulic and substrate HSC by lifestage
source("find.hsc.R"); source("bricks.rc.R"); source("by.substrate.R"); source("find.sub.R")
hsc_allspec<-fread(paste(wd,reachName,"_hsc",".csv",sep = ""), header=TRUE, sep=",",data.table = FALSE)
hsc_allages <- find.hsc(hsc_allspec,species) # extract HSC for single species
goodHabList <- lapply(lifestages, function(b) bricks.rc(b,outValRast,hsc_allages,habMets))
names(goodHabList) <- lifestages # list of Bricks by lifestage
# Not sure if this is working correctly yet
if(CheckSub == "Yes"){
sub_allspec <- fread(paste(wd,reachName,"_substrate",".csv",sep=""),header=TRUE, sep = ",",data.table = FALSE) # load substrate requirements
sub_allages <- find.sub(sub_allspec,species) # extract substrate requirements for single species
goodHabList <- lapply(lifestages, function(b) by.substrate(b, goodHabList, sub_allages,wd,reachName,shpName))
names(goodHabList) <- lifestages
} # end of if statement
## Total available habitat area by lifestage
source("total.area.R")
areaLookTab <- lapply(lifestages, function(c) total.area(c,goodHabList,modeled_q,RemoveIslands,NormalizeByL,reachL))
names(areaLookTab) <- lifestages
## Order rasters of total available habitat by modeled discharge
source("rast.by.q.R")
rastByQ <- lapply(lifestages, function(c) rast.by.q(c,goodHabList,modeled_q))
names(rastByQ) <- lifestages
outputs$areaLookTab <- areaLookTab
outputs$rastByQ <- rastByQ
return(outputs)
}) # end of species list function
# Put tables in a nice format
names(outputs) <- specieslist
tables <- lapply(specieslist, function(species){
outputs[[species]]$areaLookTab
})
names(tables) <- specieslist
subName <- "substrates_thiessen_erase.shp"
##### Run for all species #####
outputs <- list()
outputs <- lapply(specieslist, function(species){ # builds tables and maps for all species in list
## Reclassify Bricks with hydraulic and substrate HSC by lifestage
source("find.hsc.R"); source("bricks.rc.R"); source("by.substrate.R"); source("find.sub.R")
hsc_allspec<-fread(paste(wd,reachName,"_hsc",".csv",sep = ""), header=TRUE, sep=",",data.table = FALSE)
hsc_allages <- find.hsc(hsc_allspec,species) # extract HSC for single species
goodHabList <- lapply(lifestages, function(b) bricks.rc(b,outValRast,hsc_allages,habMets))
names(goodHabList) <- lifestages # list of Bricks by lifestage
# Not sure if this is working correctly yet
if(CheckSub == "Yes"){
sub_allspec <- fread(paste(wd,reachName,"_substrate",".csv",sep=""),header=TRUE, sep = ",",data.table = FALSE) # load substrate requirements
sub_allages <- find.sub(sub_allspec,species) # extract substrate requirements for single species
goodHabList <- lapply(lifestages, function(b) by.substrate(b, goodHabList, sub_allages,wd,reachName,shpName))
names(goodHabList) <- lifestages
} # end of if statement
## Total available habitat area by lifestage
source("total.area.R")
areaLookTab <- lapply(lifestages, function(c) total.area(c,goodHabList,modeled_q,RemoveIslands,NormalizeByL,reachL))
names(areaLookTab) <- lifestages
## Order rasters of total available habitat by modeled discharge
source("rast.by.q.R")
rastByQ <- lapply(lifestages, function(c) rast.by.q(c,goodHabList,modeled_q))
names(rastByQ) <- lifestages
outputs$areaLookTab <- areaLookTab
outputs$rastByQ <- rastByQ
return(outputs)
}) # end of species list function
# Put tables in a nice format
names(outputs) <- specieslist
tables <- lapply(specieslist, function(species){
outputs[[species]]$areaLookTab
})
names(tables) <- specieslist
##### Run for all species #####
outputs <- list()
outputs <- lapply(specieslist, function(species){ # builds tables and maps for all species in list
## Reclassify Bricks with hydraulic and substrate HSC by lifestage
source("find.hsc.R"); source("bricks.rc.R"); source("by.substrate.R"); source("find.sub.R")
hsc_allspec<-fread(paste(wd,reachName,"_hsc",".csv",sep = ""), header=TRUE, sep=",",data.table = FALSE)
hsc_allages <- find.hsc(hsc_allspec,species) # extract HSC for single species
goodHabList <- lapply(lifestages, function(b) bricks.rc(b,outValRast,hsc_allages,habMets))
names(goodHabList) <- lifestages # list of Bricks by lifestage
# Not sure if this is working correctly yet
if(CheckSub == "Yes"){
sub_allspec <- fread(paste(wd,reachName,"_substrate",".csv",sep=""),header=TRUE, sep = ",",data.table = FALSE) # load substrate requirements
sub_allages <- find.sub(sub_allspec,species) # extract substrate requirements for single species
goodHabList <- lapply(lifestages, function(b) by.substrate(b, goodHabList, sub_allages,wd,reachName,subName))
names(goodHabList) <- lifestages
} # end of if statement
## Total available habitat area by lifestage
source("total.area.R")
areaLookTab <- lapply(lifestages, function(c) total.area(c,goodHabList,modeled_q,RemoveIslands,NormalizeByL,reachL))
names(areaLookTab) <- lifestages
## Order rasters of total available habitat by modeled discharge
source("rast.by.q.R")
rastByQ <- lapply(lifestages, function(c) rast.by.q(c,goodHabList,modeled_q))
names(rastByQ) <- lifestages
outputs$areaLookTab <- areaLookTab
outputs$rastByQ <- rastByQ
return(outputs)
}) # end of species list function
# Put tables in a nice format
names(outputs) <- specieslist
tables <- lapply(specieslist, function(species){
outputs[[species]]$areaLookTab
})
names(tables) <- specieslist
subMap <- readOGR(dsn=paste(wd,"results","/",reachName,sep = ""),layer=subName) # read in substrate shapefile
subMap <- readOGR(dsn=paste(wd,"results","/",reachName,sep = ""),layer=subName) # read in substrate shapefile
subMap <- readOGR(dsn=paste(wd,"results","/",reachName,sep = ""),layer=subName) # read in substrate shapefile
subMap <- readOGR(dsn=paste(wd,"results","/",reachName,sep = ""),layer="substrates_thiessen_erase")# read in substrate shapefile
subName <- "substrates_thiessen_erase"
##### Run for all species #####
outputs <- list()
outputs <- lapply(specieslist, function(species){ # builds tables and maps for all species in list
## Reclassify Bricks with hydraulic and substrate HSC by lifestage
source("find.hsc.R"); source("bricks.rc.R"); source("by.substrate.R"); source("find.sub.R")
hsc_allspec<-fread(paste(wd,reachName,"_hsc",".csv",sep = ""), header=TRUE, sep=",",data.table = FALSE)
hsc_allages <- find.hsc(hsc_allspec,species) # extract HSC for single species
goodHabList <- lapply(lifestages, function(b) bricks.rc(b,outValRast,hsc_allages,habMets))
names(goodHabList) <- lifestages # list of Bricks by lifestage
# Not sure if this is working correctly yet
if(CheckSub == "Yes"){
sub_allspec <- fread(paste(wd,reachName,"_substrate",".csv",sep=""),header=TRUE, sep = ",",data.table = FALSE) # load substrate requirements
sub_allages <- find.sub(sub_allspec,species) # extract substrate requirements for single species
goodHabList <- lapply(lifestages, function(b) by.substrate(b, goodHabList, sub_allages,wd,reachName,subName))
names(goodHabList) <- lifestages
} # end of if statement
## Total available habitat area by lifestage
source("total.area.R")
areaLookTab <- lapply(lifestages, function(c) total.area(c,goodHabList,modeled_q,RemoveIslands,NormalizeByL,reachL))
names(areaLookTab) <- lifestages
## Order rasters of total available habitat by modeled discharge
source("rast.by.q.R")
rastByQ <- lapply(lifestages, function(c) rast.by.q(c,goodHabList,modeled_q))
names(rastByQ) <- lifestages
outputs$areaLookTab <- areaLookTab
outputs$rastByQ <- rastByQ
return(outputs)
}) # end of species list function
# Put tables in a nice format
names(outputs) <- specieslist
tables <- lapply(specieslist, function(species){
outputs[[species]]$areaLookTab
})
names(tables) <- specieslist
# Set Inputs
wd <- "C:/Users/epassero/Desktop/VRDSS/verde-refdss/"
#wd <- "/Users/Morrison/Documents/Active Research Projects/Verde REFDSS/verde-refdss/" # Set path to local repository
setwd(wd)
habMets <- list("depth","velocity") #Variables from iRIC calculation result used for habitat analysis ex: Velocity..magnitude.
species <- "longfindace"
lifestages <- list("adult") #lifestages from oldest to youngest; must match order in HSC table
reachName <- "Cherry_Braid" # Should match name of folder with results
DEM <- "braidallpts_DEM.tif" # Name of DEM used in iRIC: VerdeBeasley1Elev.tif or smrf_DEM_v241.tif or braidallpts_DEM.tif. If loading externally put NA
disunit <- "cfs" #units of discharge
reachL <- 0.61
subName <- "substrates_thiessen_erase"
# Secondary Inputs - Use only if switching between projects
skipnum <- 1 # number of rows to skip when reading in CSV results
setRes <- "No" # Does the resolution need to be manually set?
res <- c(0.25,0.25) # resolution of rasters if they need to be manually set
xLoc <- "x" # field name of X coordinate in CSVs
yLoc <- "y" # field name of y coordinate in CSVs
# Options: Do not use CheckSub right now
CheckSub <- "Yes" # Yes or No. Choose whether or not to check substrate conditions as part of suitable habitat
LoadExternal <- "Yes" # Yes- external rasters or No- rasterize iRIC results.
RemoveIslands <- "Yes" # Yes or No. Choose whether or not to remove isolated (single cell) habitat patches
NormalizeByL <- "Yes" # Yes or No. Choose whether or not to normalize habitat area by reach length
if(LoadExternal == "No"){
## Format result CSVs and get list of discharges
source("get.results.R")
holdList <- get.results(wd,reachName,skipnum,disunit)
csvList <- holdList$csvList
modeled_q <- holdList$modeled_q
rm(holdList)
### for cherry Creek ###
#source("exp.shp.R")
#resultsPts <- lapply(habMets, function(a) exp.shp(a,csvList,wd,DEM,reachName,xLoc,yLoc))
## Convert iRIC outputs to rasterBricks by variable
source("iric.process.smr.R")
outValRast <- list()
outValRast <- lapply(habMets, function(a) iric.process.smr(a,csvList,wd,DEM,reachName,setRes,xLoc,yLoc))
names(outValRast) <-habMets
rm(csvList)} else{
## Load in external rasterBricks and discharges
source("load.cherry.R")
#reachCode <- "del1"
outValRast <- load.cherry(wd,reachName,reachCode)
names(outValRast)<-c(habMets,"modeled_q")
modeled_q <- outValRast$modeled_q
outValRast[length(outValRast)]<-NULL
}
##### Run for all species #####
#outputs <- list()
#outputs <- lapply(specieslist, function(species){ # builds tables and maps for all species in list
## Reclassify Bricks with hydraulic and substrate HSC by lifestage
source("find.hsc.R"); source("bricks.rc.R"); source("by.substrate.R"); source("find.sub.R")
hsc_allspec<-fread(paste(wd,reachName,"_hsc",".csv",sep = ""), header=TRUE, sep=",",data.table = FALSE)
hsc_allages <- find.hsc(hsc_allspec,species) # extract HSC for single species
goodHabList <- lapply(lifestages, function(b) bricks.rc(b,outValRast,hsc_allages,habMets))
names(goodHabList) <- lifestages # list of Bricks by lifestage
# Not sure if this is working correctly yet
if(CheckSub == "Yes"){
sub_allspec <- fread(paste(wd,reachName,"_substrate",".csv",sep=""),header=TRUE, sep = ",",data.table = FALSE) # load substrate requirements
sub_allages <- find.sub(sub_allspec,species) # extract substrate requirements for single species
goodHabList <- lapply(lifestages, function(b) by.substrate(b, goodHabList, sub_allages,wd,reachName,subName))
names(goodHabList) <- lifestages
} # end of if statement
## Total available habitat area by lifestage
source("total.area.R")
areaLookTab <- lapply(lifestages, function(c) total.area(c,goodHabList,modeled_q,RemoveIslands,NormalizeByL,reachL))
names(areaLookTab) <- lifestages
## Order rasters of total available habitat by modeled discharge
source("rast.by.q.R")
rastByQ <- lapply(lifestages, function(c) rast.by.q(c,goodHabList,modeled_q))
names(rastByQ) <- lifestages
rastSubMap <- rasterize(subMap,goodRast,fun='first',update=TRUE)
b <- "adult"
pos <- grep(b,names(sub_allages),ignore.case = TRUE)
subReq <- sub_allages[,pos] # substrate requirement for current lifestage
subReq <- subReq[!is.na(subReq)] # remove any NA values
goodRast <- goodHabList[[b]] # raster of suitable habitat for current lifestage
rastSubMap <- rasterize(subMap,goodRast,fun='first',update=TRUE)
subMap["substrate"]
rastSubMap <- rasterize(subMap,goodRast,field=subMap["substrate"],fun='first',update=TRUE)
bySubBrick <- mask(goodRast,subMap,inverse=TRUE,maskvalue=subReq,updatevalue=NA) # if cells not covered by acceptable substrate or are NA, they are set to NA
subName <- "substrates_dissolve"
subMap <- readOGR(dsn=paste(wd,"results","/",reachName,sep = ""),layer=subName) # read in substrate shapefile
rastSubMap <- rasterize(subMap,goodRast,field=subMap["substrate"],fun='first',update=TRUE)
funct <- function(x,na.rm)if(na.rm)first(na.omit(x))else(first(x))
func <- function(x,na.rm)if(na.rm)first(na.omit(x))else(first(x))
rastSubMap <- rasterize(subMap,goodRast,field=subMap["substrate"],fun=func,update=TRUE,na.rm=TRUE)
